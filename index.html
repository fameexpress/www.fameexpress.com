<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fame Express | AI-Powered Amazon Ads Optimization | Free Audit</title>
    <meta name="description" content="Stop wasting money on Amazon Ads. Our AI Agent optimizes your campaigns using AMC SQL analysis. Get a free audit revealing hidden waste and profit opportunities.">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        /* =====================================================
           1. CSS RESET & BASE STYLES
           ===================================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a0f;
            color: #ffffff;
            overflow-x: hidden;
        }

        /* =====================================================
           2. CANVAS & OVERLAY LAYERS
           ===================================================== */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .grid-bg {
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            pointer-events: none;
            z-index: 2;
            opacity: 0.06;
            background-image:
                linear-gradient(rgba(0, 255, 255, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.4) 1px, transparent 1px);
            background-size: 60px 60px;
            animation: gridMove 30s linear infinite;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: center center;
        }

        @keyframes gridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(60px); }
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .scanlines::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, 0.08) 2px,
                rgba(0, 0, 0, 0.08) 4px
            );
            animation: scanlineMove 10s linear infinite;
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 50%,
                rgba(0, 0, 0, 0.4) 80%,
                rgba(0, 0, 0, 0.7) 100%
            );
        }

        /* =====================================================
           3. SCROLL CONTAINER & CHAPTERS
           ===================================================== */
        #scroll-container {
            position: relative;
            z-index: 10;
            pointer-events: none;
        }

        .chapter {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 40px;
            position: relative;
        }

        .chapter-content {
            max-width: 800px;
            text-align: center;
            pointer-events: auto;
            /* Background for readability over 3D scene */
            background: radial-gradient(ellipse at center, rgba(10, 10, 15, 0.85) 0%, rgba(10, 10, 15, 0.4) 60%, transparent 100%);
            padding: 40px;
            border-radius: 20px;
        }

        /* Chapter 1: Hero */
        #chapter-1 {
            padding-top: 100px;
        }

        #chapter-1 h1 {
            font-size: clamp(2.5rem, 6vw, 4.5rem);
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 24px;
            background: linear-gradient(135deg, #ffffff 0%, #00ffff 50%, #00ff88 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subhead {
            font-size: clamp(1.1rem, 2.5vw, 1.5rem);
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 40px;
            line-height: 1.6;
        }

        .microcopy {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 16px;
        }

        /* Chapter 2: Proof */
        #chapter-2 h2,
        #chapter-3 h2,
        #chapter-4 h2,
        #chapter-5 h2,
        #chapter-6 h2 {
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 700;
            margin-bottom: 48px;
            color: #ffffff;
        }

        .metric-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            justify-content: center;
        }

        .metric-tile {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 16px;
            padding: 32px 40px;
            min-width: 220px;
            backdrop-filter: blur(10px);
            transition: transform 0.3s, border-color 0.3s;
        }

        .metric-tile:hover {
            transform: translateY(-4px);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .metric-value {
            display: block;
            font-size: 2rem;
            font-weight: 700;
            color: #00ffff;
            margin-bottom: 8px;
            font-family: 'JetBrains Mono', monospace;
        }

        .metric-label {
            display: block;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Chapter 3: AMC */
        .query-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
            margin-top: 32px;
        }

        .query-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 24px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .query-card:hover,
        .query-card.active {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.4);
            color: #00ffff;
        }

        /* Chapter 4: Pipeline */
        .pipeline-steps {
            display: flex;
            flex-wrap: wrap;
            gap: 32px;
            justify-content: center;
            margin-top: 32px;
        }

        .step {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 32px 24px;
            width: 200px;
            text-align: center;
            transition: all 0.5s;
            position: relative;
        }

        .step.active {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: #00ffff;
        }

        .step h3 {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .step p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.5);
        }

        /* Chapter 5: Qualification */
        .qualification-checklist {
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 400px;
            margin: 32px auto 0;
            text-align: left;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .checkbox-item:hover {
            border-color: rgba(0, 255, 136, 0.3);
        }

        .checkbox-item input {
            width: 20px;
            height: 20px;
            accent-color: #00ff88;
        }

        .checkbox-item input:checked + span {
            color: #00ff88;
        }

        .checkbox-item span {
            color: rgba(255, 255, 255, 0.8);
            transition: color 0.3s;
        }

        /* Chapter 6: Form */
        .form-panel {
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 24px;
            padding: 48px 40px;
            max-width: 480px;
            margin: 0 auto;
            backdrop-filter: blur(20px);
        }

        .form-panel h2 {
            margin-bottom: 32px;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 14px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: #ffffff;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.3s, background 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: rgba(0, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.08);
        }

        .form-group select {
            cursor: pointer;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .submit-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            border: none;
            border-radius: 12px;
            color: #0a0a0f;
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .trust-line {
            margin-top: 20px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        /* =====================================================
           4. HUD COMPONENTS
           ===================================================== */
        .hud {
            position: fixed;
            z-index: 100;
            color: #00ffff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 20px;
            pointer-events: none;
        }

        .hud-tl { top: 0; left: 0; }
        .hud-tr { top: 0; right: 0; text-align: right; }
        .hud-bl { bottom: 80px; left: 0; }
        .hud-br { bottom: 80px; right: 0; text-align: right; }

        .hud-row {
            margin-bottom: 8px;
        }

        .hud-label {
            font-size: 9px;
            opacity: 0.5;
            display: block;
            margin-bottom: 2px;
        }

        .hud-value {
            font-size: 14px;
            font-weight: 500;
            text-shadow: 0 0 10px currentColor;
        }

        .waste-color { color: #ff4444; }
        .profit-color { color: #00ff88; }

        .hud-value.pulse {
            animation: valuePulse 0.4s ease-out;
        }

        @keyframes valuePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); filter: brightness(1.5); }
            100% { transform: scale(1); }
        }

        /* Hand Control Panel */
        #hand-control-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            pointer-events: auto;
        }

        .toggle-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 30px;
            color: #00ffff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .toggle-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.6);
        }

        .toggle-btn.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }

        #hand-status {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            justify-content: center;
        }

        .hand-indicator {
            text-align: center;
        }

        .hand-label {
            font-size: 9px;
            opacity: 0.5;
            display: block;
        }

        .gesture-status {
            font-size: 11px;
            font-weight: 500;
        }

        #hand-video {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            z-index: 100;
            transform: scaleX(-1);
        }

        .hidden {
            display: none !important;
        }

        /* =====================================================
           5. STICKY CTA BUTTON
           ===================================================== */
        #cta-sticky {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            padding: 16px 40px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            color: #0a0a0f;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow:
                0 5px 30px rgba(0, 255, 136, 0.4),
                0 0 60px rgba(0, 255, 136, 0.15);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: inherit;
            pointer-events: auto;
        }

        #cta-sticky:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow:
                0 8px 40px rgba(0, 255, 136, 0.5),
                0 0 80px rgba(0, 255, 136, 0.25);
        }

        #cta-sticky.pulse {
            animation: ctaPulse 2s ease-in-out infinite;
        }

        @keyframes ctaPulse {
            0%, 100% { box-shadow: 0 5px 30px rgba(0, 255, 136, 0.4); }
            50% { box-shadow: 0 5px 50px rgba(0, 255, 136, 0.6); }
        }

        /* =====================================================
           6. TOOLTIP
           ===================================================== */
        #tooltip {
            position: fixed;
            z-index: 300;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid rgba(255, 68, 68, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip .tooltip-label {
            font-size: 0.9rem;
            color: #ff4444;
            font-weight: 600;
            margin-bottom: 4px;
        }

        #tooltip .tooltip-value {
            font-size: 1.1rem;
            color: #00ff88;
            font-family: 'JetBrains Mono', monospace;
        }

        /* =====================================================
           7. ACCESSIBILITY
           ===================================================== */
        .reduce-motion .grid-bg,
        .reduce-motion .scanlines::after {
            animation: none !important;
        }

        .reduce-motion #main-canvas {
            opacity: 0.3;
        }

        .hud-btn {
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }

        .hud-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            color: #ffffff;
        }

        .hud-btn.active {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.4);
            color: #00ff88;
        }

        /* =====================================================
           8. GAME MODE STYLES
           ===================================================== */
        #play-mode-btn {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            padding: 12px 28px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(255, 102, 0, 0.2);
            color: #ff6600;
            border: 2px solid #ff6600;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #play-mode-btn:hover {
            background: rgba(255, 102, 0, 0.3);
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.4);
            transform: translateX(-50%) scale(1.05);
        }

        #game-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 250;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            gap: 40px;
            pointer-events: none;
        }

        .game-stat {
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .game-stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'JetBrains Mono', monospace;
        }

        .game-stat-value {
            font-size: 36px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
        }

        #game-timer .game-stat-value {
            color: #ff6600;
            text-shadow: 0 0 20px #ff6600;
        }

        #game-timer.warning .game-stat-value {
            color: #ff3333;
            animation: timerPulse 0.5s ease-in-out infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .combo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .combo-meter {
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .combo-meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff88, #00ffff);
            transition: width 0.2s;
            border-radius: 4px;
        }

        .combo-multiplier {
            font-size: 28px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: #00ff88;
            text-shadow: 0 0 15px #00ff88;
        }

        .combo-multiplier.level-up {
            animation: comboLevelUp 0.3s ease-out;
        }

        @keyframes comboLevelUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); filter: brightness(2); }
            100% { transform: scale(1); }
        }

        /* Countdown Overlay */
        #countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .countdown-number {
            font-size: 200px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: #00ffff;
            text-shadow: 0 0 60px #00ffff, 0 0 120px #00ffff;
            animation: countdownPop 1s ease-out;
        }

        @keyframes countdownPop {
            0% { transform: scale(2); opacity: 0; }
            50% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        /* Results Screen */
        #results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 400;
            padding: 20px;
        }

        .results-title {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 20px;
        }

        .results-main-score {
            font-size: 72px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: #00ff88;
            text-shadow: 0 0 40px #00ff88;
            margin-bottom: 10px;
        }

        .results-label {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 40px;
        }

        .results-stats {
            display: flex;
            gap: 60px;
            margin-bottom: 40px;
        }

        .results-stat {
            text-align: center;
        }

        .results-stat-value {
            font-size: 32px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            color: #00ffff;
        }

        .results-stat-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rank-badge {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 40px;
            animation: rankReveal 0.5s ease-out;
        }

        .rank-badge.rank-S { background: linear-gradient(135deg, #ffd700, #ff8c00); color: #000; box-shadow: 0 0 60px #ffd700; }
        .rank-badge.rank-A { background: linear-gradient(135deg, #00ff88, #00ccff); color: #000; box-shadow: 0 0 40px #00ff88; }
        .rank-badge.rank-B { background: linear-gradient(135deg, #00ccff, #0088ff); color: #000; box-shadow: 0 0 30px #00ccff; }
        .rank-badge.rank-C { background: linear-gradient(135deg, #888, #666); color: #fff; }
        .rank-badge.rank-D { background: linear-gradient(135deg, #663333, #442222); color: #fff; }

        @keyframes rankReveal {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        .results-actions {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .results-btn {
            padding: 14px 32px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s;
        }

        .results-btn.primary {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #0a0a0f;
        }

        .results-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .results-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }

        .results-btn.cta-audit {
            background: linear-gradient(135deg, #ff6600, #ff3300);
            color: #fff;
            font-size: 16px;
            padding: 16px 40px;
            animation: ctaPulse 2s infinite;
        }

        .results-btn.cta-audit:hover {
            box-shadow: 0 10px 40px rgba(255, 102, 0, 0.5);
        }

        @keyframes ctaPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 102, 0, 0.4); }
            50% { box-shadow: 0 0 25px rgba(255, 102, 0, 0.8); }
        }

        /* Number Popups */
        .number-popup {
            position: fixed;
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88;
            pointer-events: none;
            z-index: 500;
            transform: translateY(0) scale(1);
            opacity: 1;
            transition: transform 0.8s ease-out, opacity 0.8s ease-out;
        }

        .number-popup.animate {
            transform: translateY(-80px) scale(1.3);
            opacity: 0;
        }

        /* Flash Effect */
        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
        }

        /* Sound Toggle */
        #sound-toggle {
            position: fixed;
            top: 140px;
            right: 20px;
            z-index: 150;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        #sound-toggle:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #00ffff;
        }

        #sound-toggle.muted {
            color: #666;
            border-color: #444;
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 140, 0, 0.2));
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 600;
            transition: top 0.5s ease-out;
        }

        .achievement-notification.show {
            top: 20px;
        }

        .achievement-icon {
            font-size: 32px;
        }

        .achievement-content {
            display: flex;
            flex-direction: column;
        }

        .achievement-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #ffd700;
        }

        .achievement-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.9);
            color: #0a0a0f;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 700;
            transition: bottom 0.3s ease-out;
        }

        .toast.show {
            bottom: 140px;
        }

        /* Calculator Overlay */
        #calculator-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 350;
            padding: 20px;
        }

        .calculator-panel {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 24px;
            padding: 48px;
            max-width: 500px;
            text-align: center;
        }

        .calculator-panel h2 {
            font-size: 28px;
            margin-bottom: 12px;
            color: #fff;
        }

        .calculator-subtitle {
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 32px;
        }

        .spend-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
        }

        .spend-input-group .currency {
            font-size: 32px;
            color: #00ff88;
            font-family: 'JetBrains Mono', monospace;
        }

        .spend-input-group input {
            width: 200px;
            padding: 16px;
            font-size: 28px;
            font-family: 'JetBrains Mono', monospace;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            color: #fff;
            text-align: center;
        }

        .spend-input-group input:focus {
            outline: none;
            border-color: #00ffff;
        }

        .spend-input-group .period {
            color: rgba(255, 255, 255, 0.5);
        }

        .analyze-btn {
            padding: 16px 40px;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #0a0a0f;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .analyze-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.4);
        }

        .calc-skip {
            margin-top: 24px;
        }

        .calc-skip a {
            color: rgba(255, 255, 255, 0.4);
            text-decoration: none;
        }

        .calc-skip a:hover {
            color: #00ffff;
        }

        /* Analysis Animation */
        #analysis-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 360;
            padding: 20px;
        }

        .analysis-progress {
            width: 400px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 30px 0;
        }

        .analysis-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff88, #00ffff);
            transition: width 0.1s;
        }

        .sql-scroll {
            width: 500px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #00ffff;
            text-align: left;
            margin-bottom: 30px;
        }

        .sql-query {
            margin-bottom: 8px;
            opacity: 0.7;
        }

        .analysis-counters {
            display: flex;
            gap: 60px;
        }

        .analysis-counter {
            text-align: center;
        }

        .analysis-counter-value {
            font-size: 36px;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }

        .analysis-counter-value.spend { color: #ff6600; }
        .analysis-counter-value.waste { color: #ff3333; }

        .analysis-counter-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
        }

        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 800;
        }

        /* God Mode */
        body.god-mode .grid-bg {
            animation: godModeGrid 2s linear infinite;
            opacity: 0.15;
        }

        @keyframes godModeGrid {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .god-mode-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            z-index: 900;
            animation: godModeText 3s ease-out forwards;
            display: flex;
            gap: 20px;
        }

        @keyframes godModeText {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* =====================================================
           8B. ENEMY HIT LABELS
           ===================================================== */
        @keyframes hitLabelPop {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3);
            }
            30% {
                transform: translate(-50%, -50%) scale(1);
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -100%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150%) scale(0.8);
            }
        }

        .enemy-hit-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .enemy-hit-label .hit-type {
            font-size: 16px;
            letter-spacing: 2px;
        }

        .enemy-hit-label .hit-value {
            font-size: 12px;
            opacity: 0.8;
        }

        /* Boost collect labels */
        .boost-collect-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 700;
            animation: boostCollectPop 1s ease-out forwards;
        }

        @keyframes boostCollectPop {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5);
            }
            40% {
                transform: translate(-50%, -50%) scale(1.2);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150%) scale(1);
            }
        }

        /* =====================================================
           9. RESPONSIVE
           ===================================================== */
        @media (max-width: 768px) {
            .chapter {
                padding: 40px 20px;
            }

            .metric-tiles {
                flex-direction: column;
                align-items: center;
            }

            .pipeline-steps {
                flex-direction: column;
                align-items: center;
            }

            .hud {
                font-size: 10px;
                padding: 12px;
            }

            .hud-value {
                font-size: 12px;
            }

            #cta-sticky {
                padding: 14px 28px;
                font-size: 12px;
            }

            .form-panel {
                padding: 32px 24px;
            }

            #hand-video {
                width: 120px;
                height: 90px;
            }

            /* Hide combo box on mobile to save space */
            #game-hud .game-stat:last-child {
                display: none;
            }

            /* Reduce gap for remaining boxes */
            #game-hud {
                gap: 20px;
            }
        }

        /* =====================================================
           NEW SECTIONS: What You Get, Case Study, Founder, FAQ
           ===================================================== */

        /* What You Get Section */
        .what-you-get-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 48px;
            margin-top: 48px;
            text-align: left;
        }

        @media (max-width: 900px) {
            .what-you-get-grid {
                grid-template-columns: 1fr;
                gap: 32px;
            }
        }

        .deliverable-column h3 {
            font-size: 1.3rem;
            color: #00ffff;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .deliverable-column h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #00ffff;
            border-radius: 50%;
        }

        .deliverable-list {
            list-style: none;
            margin-bottom: 32px;
        }

        .deliverable-list li {
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .deliverable-list li::before {
            content: 'âœ“';
            color: #00ff88;
            font-weight: bold;
        }

        .screenshot-frame {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px;
            overflow: hidden;
            transition: transform 0.3s, border-color 0.3s;
        }

        .screenshot-frame:hover {
            transform: scale(1.02);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .screenshot-frame img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }

        .screenshot-caption {
            text-align: center;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 12px;
        }

        /* Case Study Section */
        .case-study-section {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 255, 255, 0.05) 100%);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 24px;
            padding: 48px;
            margin-top: 32px;
        }

        .case-study-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .case-study-header .eyebrow {
            font-size: 0.85rem;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 16px;
        }

        .case-study-stats {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 32px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 16px;
            padding: 24px 32px;
            text-align: center;
            min-width: 180px;
        }

        .stat-card .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #00ff88;
            font-family: 'JetBrains Mono', monospace;
            display: block;
            margin-bottom: 8px;
        }

        .stat-card .stat-label {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .stat-card.highlight {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.5);
        }

        .stat-card.highlight .stat-value {
            font-size: 2.5rem;
        }

        /* Founder Section */
        .founder-section {
            display: flex;
            align-items: center;
            gap: 48px;
            text-align: left;
            margin-top: 32px;
        }

        @media (max-width: 768px) {
            .founder-section {
                flex-direction: column;
                text-align: center;
            }
        }

        .founder-avatar {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 255, 136, 0.2) 100%);
            border: 3px solid rgba(0, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            flex-shrink: 0;
            overflow: hidden;
        }

        .founder-bio h3 {
            font-size: 1.5rem;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .founder-bio .founder-title {
            color: #00ffff;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .founder-bio p {
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.7;
            margin-bottom: 16px;
        }

        .founder-credentials {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 24px;
        }

        .credential-badge {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* FAQ Section */
        .faq-container {
            max-width: 700px;
            margin: 48px auto 0;
            text-align: left;
        }

        .faq-item {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0;
        }

        .faq-question {
            width: 100%;
            background: transparent;
            border: none;
            color: #ffffff;
            font-size: 1.1rem;
            padding: 24px 0;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: inherit;
            transition: color 0.3s;
        }

        .faq-question:hover {
            color: #00ffff;
        }

        .faq-question::after {
            content: '+';
            font-size: 1.5rem;
            color: #00ffff;
            transition: transform 0.3s;
        }

        .faq-item.active .faq-question::after {
            transform: rotate(45deg);
        }

        .faq-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.7;
        }

        .faq-item.active .faq-answer {
            max-height: 300px;
            padding-bottom: 24px;
        }

        /* Footer */
        footer {
            position: relative;
            z-index: 10;
            background: #1a1a1a;
            color: #999;
            text-align: center;
            padding: 30px 20px;
            font-size: 0.9rem;
            margin-top: 60px;
            margin-bottom: 200px;
        }

        footer a {
            color: #FF9900;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Image Lightbox */
        #image-lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #image-lightbox.active {
            opacity: 1;
            pointer-events: auto;
        }

        .lightbox-container {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .lightbox-image {
            width: auto;
            height: auto;
            max-width: 85vw;
            max-height: 80vh;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 10px 50px rgba(0, 255, 255, 0.2);
        }

        .lightbox-caption {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            margin-top: 16px;
            text-align: center;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 40px;
            color: #00ffff;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 2001;
            line-height: 1;
        }

        .lightbox-close:hover {
            color: #ffffff;
            transform: scale(1.2);
        }

        .screenshot-frame {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- =====================================================
         CANVAS CONTAINER
         ===================================================== -->
    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
    </div>
    <div class="grid-bg"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <!-- =====================================================
         SCROLL CONTAINER WITH CHAPTERS
         ===================================================== -->
    <div id="scroll-container">
        <!-- Chapter 1: Hero -->
        <section id="chapter-1" class="chapter" aria-label="Hero">
            <div class="chapter-content">
                <p class="microcopy" style="margin-bottom: 16px; font-size: 1rem;">If you're spending $50K+/month on Amazon Ads but can't prove what's actually working...</p>
                <h1>There's a Better Way to Optimize Amazon Ads</h1>
                <p class="subhead">Our AI-powered AMC analysis reveals hidden waste, unlocks growth opportunities, and shows you exactly where your ad dollars should go.</p>
                <p class="microcopy">No commitment. Results in ~48 hours.</p>
            </div>
        </section>

        <!-- NEW: What You Get Section -->
        <section id="what-you-get" class="chapter" aria-label="What You Get">
            <div class="chapter-content" style="max-width: 1000px;">
                <h2>What You Get</h2>
                <p class="subhead">A comprehensive audit plus ongoing access to powerful analytics</p>

                <div class="what-you-get-grid">
                    <!-- Audit Deliverables Column -->
                    <div class="deliverable-column">
                        <h3>Free Audit Report</h3>
                        <ul class="deliverable-list">
                            <li>17+ page comprehensive analysis</li>
                            <li>Prioritized action plan (Critical/High/Medium)</li>
                            <li>Wasted spend identification</li>
                            <li>Incremental sales opportunities</li>
                            <li>Campaign synergy insights</li>
                        </ul>
                        <div class="screenshot-frame">
                            <img src="assets/screenshots/audit-action-plan.png" alt="Audit Action Plan showing prioritized recommendations" loading="lazy">
                        </div>
                        <p class="screenshot-caption">Prioritized action plan with potential value</p>
                        <div class="screenshot-frame">
                            <img src="assets/screenshots/audit-path-to-purchase.png" alt="Path to Purchase Attribution Analysis" loading="lazy">
                        </div>
                        <p class="screenshot-caption">Multi-touch attribution and customer journey insights</p>
                    </div>

                    <!-- Platform Access Column -->
                    <div class="deliverable-column">
                        <h3>Platform Access</h3>
                        <ul class="deliverable-list">
                            <li>Smart Recommendations dashboard</li>
                            <li>Multi-touch attribution analysis</li>
                            <li>Customer journey visualization</li>
                            <li>Campaign performance tracking</li>
                            <li>Real-time data updates</li>
                        </ul>
                        <div class="screenshot-frame">
                            <img src="assets/screenshots/amc-smart-recommendations.png" alt="Smart Recommendations Dashboard" loading="lazy">
                        </div>
                        <p class="screenshot-caption">AI-powered campaign recommendations</p>
                        <div class="screenshot-frame">
                            <img src="assets/screenshots/amc-creative-recommendations.png" alt="Creative Performance Analysis Dashboard" loading="lazy">
                        </div>
                        <p class="screenshot-caption">Creative performance analysis with actionable insights</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Chapter 2: Proof -->
        <section id="chapter-2" class="chapter" aria-label="Proof">
            <div class="chapter-content">
                <h2>What Competitors Are Discovering</h2>
                <div class="metric-tiles">
                    <div class="metric-tile" data-metric="waste">
                        <span class="metric-value">$170K+</span>
                        <span class="metric-label">Monthly waste found</span>
                    </div>
                    <div class="metric-tile" data-metric="sql">
                        <span class="metric-value">17+ Pages</span>
                        <span class="metric-label">SQL queries generated</span>
                    </div>
                    <div class="metric-tile" data-metric="api">
                        <span class="metric-value">Full API</span>
                        <span class="metric-label">Ads + SP + Stream</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- NEW: Case Study Section -->
        <section id="case-study" class="chapter" aria-label="Case Study">
            <div class="chapter-content" style="max-width: 900px;">
                <div class="case-study-section">
                    <div class="case-study-header">
                        <p class="eyebrow">Real Results</p>
                        <h2>One Client Discovered $393,646 in Total Optimization Opportunity</h2>
                    </div>

                    <div class="case-study-stats">
                        <div class="stat-card highlight">
                            <span class="stat-value">$393K</span>
                            <span class="stat-label">Total Opportunity</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value">$69K</span>
                            <span class="stat-label">Wasted Spend</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value">$294K</span>
                            <span class="stat-label">Incremental Sales</span>
                        </div>
                        <div class="stat-card">
                            <span class="stat-value">215</span>
                            <span class="stat-label">Critical Actions</span>
                        </div>
                    </div>

                    <div class="screenshot-frame" style="max-width: 700px; margin: 0 auto;">
                        <img src="assets/screenshots/amc-sankey-chart.png" alt="Customer Journey Flow Analysis" loading="lazy">
                    </div>
                    <p class="screenshot-caption">Customer journey flow analysis reveals hidden conversion paths</p>
                </div>
            </div>
        </section>

        <!-- Chapter 3: AMC -->
        <section id="chapter-3" class="chapter" aria-label="AMC">
            <div class="chapter-content">
                <h2>Answer Complex Business Questions</h2>
                <p class="subhead">Our AI generates custom AMC SQL queries to unlock insights your competitors can't see</p>
                <div class="query-cards">
                    <button class="query-card active" data-query="attribution">Attribution Paths</button>
                    <button class="query-card" data-query="frequency">Frequency Sweet Spot</button>
                    <button class="query-card" data-query="overlap">Channel Interactions</button>
                    <button class="query-card" data-query="incrementality">Incrementality</button>
                    <button class="query-card" data-query="audience">Best Audiences</button>
                    <button class="query-card" data-query="realtime">Real-time Stream</button>
                </div>
            </div>
        </section>

        <!-- Chapter 4: Pipeline -->
        <section id="chapter-4" class="chapter" aria-label="Pipeline">
            <div class="chapter-content">
                <h2>How the Free Audit Works</h2>
                <div class="pipeline-steps">
                    <div class="step" data-step="1">
                        <div class="step-number">1</div>
                        <h3>Schedule Call</h3>
                        <p>15-minute intro</p>
                    </div>
                    <div class="step" data-step="2">
                        <div class="step-number">2</div>
                        <h3>Connect Account</h3>
                        <p>Read-only access</p>
                    </div>
                    <div class="step" data-step="3">
                        <div class="step-number">3</div>
                        <h3>AI Analysis</h3>
                        <p>SQL generation</p>
                    </div>
                    <div class="step" data-step="4">
                        <div class="step-number">4</div>
                        <h3>Get Report</h3>
                        <p>Results in ~48hrs</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- NEW: Founder Story Section -->
        <section id="founder" class="chapter" aria-label="About the Founder">
            <div class="chapter-content" style="max-width: 900px;">
                <h2>Built by Someone Who's Been There</h2>
                <div class="founder-section">
                    <div class="founder-avatar">
                        <img src="assets/anand-headshot-2025.jpg" alt="Anand Chhatpar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">
                    </div>
                    <div class="founder-bio">
                        <h3>Anand Chhatpar</h3>
                        <p class="founder-title">Founder, Fame Express</p>
                        <p>With 20+ years as a technical founder, I've learned that sustainable growth comes from data-driven decisions, not guesswork. I built Facebook apps to 20M+ users without paid advertising, then led Mystery Science to become America's #1 elementary science curriculum before its $125M+ acquisition.</p>
                        <p>Now I'm applying those same growth engineering principles to Amazon advertising. Fame Express was built to give brands the same advanced analytics and AI-powered insights that the biggest advertisers use.</p>
                        <div class="founder-credentials">
                            <span class="credential-badge">8 Patents</span>
                            <span class="credential-badge">a16z Funded</span>
                            <span class="credential-badge">Reforge Graduate</span>
                            <span class="credential-badge">20+ Years Tech</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Chapter 5: Qualification -->
        <section id="chapter-5" class="chapter" aria-label="Qualification">
            <div class="chapter-content">
                <h2>Is This Right for You?</h2>
                <div class="qualification-checklist">
                    <label class="checkbox-item">
                        <input type="checkbox" id="q1">
                        <span>Spend $50K+/month on Amazon Ads</span>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="q2">
                        <span>Want to reduce wasted spend</span>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="q3">
                        <span>Looking for growth opportunities</span>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="q4">
                        <span>Have or can get AMC access</span>
                    </label>
                </div>
            </div>
        </section>

        <!-- NEW: FAQ Section -->
        <section id="faq" class="chapter" aria-label="Frequently Asked Questions">
            <div class="chapter-content" style="max-width: 800px;">
                <h2>Common Questions</h2>

                <div class="faq-container">
                    <div class="faq-item">
                        <button class="faq-question" type="button">How is this different from Amazon's built-in reporting?</button>
                        <div class="faq-answer">
                            Amazon's standard reports show basic metrics like clicks and sales. Our AMC-powered analysis reveals the complete customer journey across touchpoints, showing you which campaigns work together, where customers drop off, and where you're wasting money on duplicate impressions. It's the difference between seeing individual puzzle pieces and seeing the whole picture.
                        </div>
                    </div>

                    <div class="faq-item">
                        <button class="faq-question" type="button">What is AMC and why does it matter?</button>
                        <div class="faq-answer">
                            Amazon Marketing Cloud (AMC) is Amazon's advanced analytics platform that lets you run SQL queries against your advertising data at the impression level. This means you can analyze customer journeys, attribution paths, and audience overlaps that are impossible to see in standard reports. Only ~5% of advertisers use AMC effectively.
                        </div>
                    </div>

                    <div class="faq-item">
                        <button class="faq-question" type="button">How long does the audit take?</button>
                        <div class="faq-answer">
                            After our initial 15-minute call and connecting your account (read-only access), our AI generates the analysis within 48 hours. You'll receive a comprehensive report with prioritized recommendations you can act on immediately.
                        </div>
                    </div>

                    <div class="faq-item">
                        <button class="faq-question" type="button">What happens after I get my audit?</button>
                        <div class="faq-answer">
                            You'll have a detailed action plan with specific recommendations prioritized by impact. We'll walk you through the findings and you can implement the changes yourself, have your team do it, or work with us on an ongoing basis for continued optimization.
                        </div>
                    </div>

                    <div class="faq-item">
                        <button class="faq-question" type="button">Is my data secure?</button>
                        <div class="faq-answer">
                            Absolutely. We only request read-only access to your advertising dataâ€”we can't make changes to your campaigns. Your data is processed securely and never shared with third parties. We take data security as seriously as our own.
                        </div>
                    </div>

                    <div class="faq-item">
                        <button class="faq-question" type="button">What if I don't have AMC access yet?</button>
                        <div class="faq-answer">
                            No problem! If you're spending $50K+/month on Amazon Ads, you likely qualify for AMC access. We can help guide you through the setup process as part of getting started. Most brands can get access within a few days.
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Chapter 6: Form -->
        <section id="chapter-6" class="chapter" aria-label="Convert">
            <div class="chapter-content">
                <div class="form-panel">
                    <h2>Request Your Free Audit</h2>
                    <form id="audit-form" action="https://api.web3forms.com/submit" method="POST">
                        <!-- Web3Forms Access Key -->
                        <input type="hidden" name="access_key" value="3ae97641-1daa-420a-a7a3-62b4213230a9">
                        <input type="hidden" name="subject" value="Free Amazon Ads Audit Request">
                        <input type="hidden" name="from_name" value="Fame Express - Free Audit">
                        <input type="hidden" name="redirect" value="https://www.fameexpress.com/thank-you.html">

                        <!-- Anti-spam -->
                        <input type="checkbox" name="botcheck" class="hidden" style="display: none;">

                        <div class="form-group">
                            <label for="name">Name *</label>
                            <input type="text" id="name" name="name" required placeholder="Your name">
                        </div>
                        <div class="form-group">
                            <label for="email">Work Email *</label>
                            <input type="email" id="email" name="email" required placeholder="you@company.com">
                        </div>
                        <div class="form-group">
                            <label for="company">Company *</label>
                            <input type="text" id="company" name="company" required placeholder="Company name">
                        </div>
                        <div class="form-group">
                            <label for="monthly-spend">Monthly Amazon Ads Spend *</label>
                            <select id="monthly-spend" name="Monthly Amazon Ads Spend" required>
                                <option value="">Select your monthly spend</option>
                                <option value="$1K - $50K">$1K - $50K</option>
                                <option value="$50K - $100K">$50K - $100K</option>
                                <option value="$100K - $250K">$100K - $250K</option>
                                <option value="$250K - $500K">$250K - $500K</option>
                                <option value="$500K+">$500K+</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="message">What's your biggest Amazon Ads challenge? (optional)</label>
                            <textarea id="message" name="message" rows="3" placeholder="e.g., High ACoS, scaling issues, attribution uncertainty..."></textarea>
                        </div>
                        <button type="submit" class="submit-btn">Get My Free Audit</button>
                    </form>
                    <p class="trust-line">
                        <span>&#128274;</span>
                        Your data is secure. Response within 1 business day.
                    </p>
                </div>
            </div>
        </section>
    </div>

    <!-- =====================================================
         HUD
         ===================================================== -->
    <div class="hud hud-tl">
        <div class="hud-row">
            <span class="hud-label">FPS</span>
            <span class="hud-value" id="fps">60</span>
        </div>
        <div class="hud-row">
            <span class="hud-label">Chapter</span>
            <span class="hud-value" id="chapter-num">1</span>
        </div>
    </div>

    <div class="hud hud-tr">
        <div class="hud-row">
            <span class="hud-label">Waste Detected</span>
            <span class="hud-value waste-color" id="waste-amount">$0</span>
        </div>
        <div class="hud-row">
            <span class="hud-label">Savings Unlocked</span>
            <span class="hud-value profit-color" id="savings-amount">$0</span>
        </div>
    </div>

    <div class="hud hud-bl">
        <div class="hud-row">
            <span class="hud-label">SQL Queries</span>
            <span class="hud-value" id="sql-count">0</span>
        </div>
    </div>

    <!-- =====================================================
         STICKY CTA
         ===================================================== -->
    <button id="cta-sticky">Get Free Audit</button>

    <!-- =====================================================
         TOOLTIP
         ===================================================== -->
    <div id="tooltip">
        <div class="tooltip-label"></div>
        <div class="tooltip-value"></div>
    </div>

    <!-- =====================================================
         PLAY MODE BUTTON
         ===================================================== -->
    <button id="play-mode-btn">
        <span>&#127918;</span>
        <span>PLAY MODE</span>
    </button>

    <!-- =====================================================
         GAME HUD (hidden by default)
         ===================================================== -->
    <div id="game-hud" class="hidden">
        <div class="game-stat" id="game-timer">
            <div class="game-stat-label">Time</div>
            <div class="game-stat-value" id="game-time">60</div>
        </div>
        <div class="game-stat">
            <div class="game-stat-label">Score</div>
            <div class="game-stat-value" id="game-score">$0</div>
        </div>
        <div class="game-stat">
            <div class="combo-container">
                <div class="game-stat-label">Combo</div>
                <div class="combo-meter">
                    <div class="combo-meter-fill" id="combo-fill"></div>
                </div>
                <div class="combo-multiplier" id="combo-multiplier">1x</div>
            </div>
        </div>
    </div>

    <!-- =====================================================
         COUNTDOWN OVERLAY (hidden by default)
         ===================================================== -->
    <div id="countdown-overlay" class="hidden">
        <div class="countdown-number" id="countdown-number">3</div>
    </div>

    <!-- =====================================================
         RESULTS SCREEN (hidden by default)
         ===================================================== -->
    <div id="results-screen" class="hidden">
        <div class="results-title">GAME OVER</div>
        <div class="rank-badge rank-B" id="result-rank-badge">B</div>
        <div class="results-main-score" id="result-score">$0</div>
        <div class="results-label">Waste Crushed in 30 Seconds</div>
        <div class="results-stats">
            <div class="results-stat">
                <div class="results-stat-value" id="result-combo">1x</div>
                <div class="results-stat-label">Best Combo</div>
            </div>
            <div class="results-stat">
                <div class="results-stat-value" id="result-captures">0</div>
                <div class="results-stat-label">Captures</div>
            </div>
        </div>
        <div class="results-actions">
            <button class="results-btn cta-audit" id="get-audit-btn">Get Free Audit</button>
            <button class="results-btn primary" id="play-again-btn">Play Again</button>
            <button class="results-btn secondary" id="share-btn">Share Result</button>
            <button class="results-btn secondary" id="close-results-btn">Close</button>
        </div>
    </div>

    <!-- =====================================================
         CALCULATOR OVERLAY (hidden by default)
         ===================================================== -->
    <div id="calculator-overlay" class="hidden">
        <div class="calculator-panel">
            <h2>How Much Are You Wasting?</h2>
            <p class="calculator-subtitle">Enter your monthly ad spend for a personalized AI analysis</p>
            <div class="spend-input-group">
                <span class="currency">$</span>
                <input type="number" id="spend-input" placeholder="50000" min="1000" step="1000">
                <span class="period">/mo</span>
            </div>
            <button class="analyze-btn" id="analyze-btn">Analyze My Spend</button>
            <p class="calc-skip">
                <a href="#" id="skip-calc">Skip and explore</a>
            </p>
        </div>
    </div>

    <!-- =====================================================
         ANALYSIS OVERLAY (hidden by default)
         ===================================================== -->
    <div id="analysis-overlay" class="hidden">
        <div class="analysis-title" style="font-size: 24px; margin-bottom: 10px;">AI Analysis in Progress...</div>
        <div class="analysis-progress">
            <div class="analysis-progress-fill" id="analysis-progress"></div>
        </div>
        <div class="sql-scroll" id="sql-scroll"></div>
        <div class="analysis-counters">
            <div class="analysis-counter">
                <div class="analysis-counter-value spend" id="counter-spend">$0</div>
                <div class="analysis-counter-label">Spend Analyzed</div>
            </div>
            <div class="analysis-counter">
                <div class="analysis-counter-value waste" id="counter-waste">$0</div>
                <div class="analysis-counter-label">Hidden Waste Found</div>
            </div>
        </div>
    </div>

    <!-- =====================================================
         SOUND TOGGLE
         ===================================================== -->
    <button id="sound-toggle" title="Toggle Sound">&#128266;</button>

    <!-- =====================================================
         FLASH EFFECT OVERLAY
         ===================================================== -->
    <div id="flash-overlay"></div>

    <!-- =====================================================
         CONFETTI CANVAS
         ===================================================== -->
    <canvas id="confetti-canvas"></canvas>

    <!-- =====================================================
         SHARE CANVAS (for generating share images)
         ===================================================== -->
    <canvas id="share-canvas" width="1200" height="630" style="display: none;"></canvas>

    <!-- =====================================================
         DEPENDENCIES
         ===================================================== -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>

    <script>
        // =====================================================
        // 1. CONFIGURATION
        // =====================================================
        const CONFIG = {
            particles: {
                baseCount: 10000, // Reduced by half for performance
                minCount: 5000,
                maxCount: 15000,
                species: {
                    spend: { ratio: 0.50, color: [1.0, 0.4, 0.1], turbulence: 0.1 },
                    waste: { ratio: 0.20, color: [1.0, 0.15, 0.15], turbulence: 0.3 },
                    profit: { ratio: 0.30, color: [0.0, 1.0, 0.55], turbulence: 0.05 }
                }
            },
            chapters: {
                1: { start: 0, end: 0.16, camera: { x: 0, y: 0, z: 400 } },
                2: { start: 0.16, end: 0.33, camera: { x: 0, y: 0, z: 400 } },
                3: { start: 0.33, end: 0.50, camera: { x: 0, y: 0, z: 400 } },
                4: { start: 0.50, end: 0.66, camera: { x: 0, y: 0, z: 400 } },
                5: { start: 0.66, end: 0.83, camera: { x: 0, y: 0, z: 400 } },
                6: { start: 0.83, end: 1.0, camera: { x: 0, y: 0, z: 400 } }
            },
            // 3D Play Area bounds (enemies spawn/move here, BEHIND text)
            playArea: {
                minX: -350, maxX: 350,
                minY: -180, maxY: 180,
                minZ: -400, maxZ: -100  // Negative Z = behind camera focal point
            },
            physics: {
                streamSpeed: 0.8,
                cohesion: 0.008,
                damping: 0.97,
                handRadius: 80,
                handStrength: 0.4
            },
            // ENEMY TYPES - distinct 3D objects with unique visuals (BRIGHT NEON COLORS)
            enemyTypes: [
                {
                    id: 'placement',
                    label: 'Placement Waste',
                    shortLabel: 'PLACEMENT',
                    color: 0xff4444,      // Bright red
                    glowColor: '#ff4444',
                    shape: 'cube',
                    size: 22,             // Larger for visibility
                    points: 500,
                    value: '$9,600/mo',
                    behavior: 'drift'  // Slow horizontal drift
                },
                {
                    id: 'overlap',
                    label: 'Audience Overlap',
                    shortLabel: 'OVERLAP',
                    color: 0xff8800,      // Bright orange
                    glowColor: '#ff8800',
                    shape: 'rings',
                    size: 26,             // Larger
                    points: 750,
                    value: '$8,200/mo',
                    behavior: 'orbit'
                },
                {
                    id: 'frequency',
                    label: 'Frequency Fatigue',
                    shortLabel: 'FREQUENCY',
                    color: 0xffdd00,      // Bright yellow
                    glowColor: '#ffdd00',
                    shape: 'pulse',
                    size: 20,             // Larger
                    points: 600,
                    value: '$15,800/mo',
                    behavior: 'pulse'
                },
                {
                    id: 'cannibalize',
                    label: 'Keyword Cannibalization',
                    shortLabel: 'CANNIBAL',
                    color: 0xff2222,      // Bright red (was too dark)
                    glowColor: '#ff2222',
                    shape: 'chomper',
                    size: 24,             // Larger
                    points: 800,
                    value: '$12,400/mo',
                    behavior: 'chase'
                },
                {
                    id: 'increment',
                    label: 'Incrementality Gap',
                    shortLabel: 'INCREMENT',
                    color: 0xcc55ff,      // Brighter purple
                    glowColor: '#cc55ff',
                    shape: 'fragment',
                    size: 28,             // Larger
                    points: 1000,
                    value: '$22,000/mo',
                    behavior: 'split'
                },
                {
                    id: 'daypart',
                    label: 'Dayparting Inefficiency',
                    shortLabel: 'DAYPART',
                    color: 0xff66aa,      // Brighter pink
                    glowColor: '#ff66aa',
                    shape: 'clock',
                    size: 22,             // Larger
                    points: 550,
                    value: '$6,100/mo',
                    behavior: 'zigzag'
                }
            ],
            // BOOST TYPES - positive pickups that help the player
            boostTypes: [
                {
                    id: 'amc_insight',
                    label: 'AMC Insight',
                    shortLabel: '+INSIGHT',
                    color: 0x00ff88,
                    glowColor: '#00ff88',
                    shape: 'diamond',
                    size: 14,
                    effect: 'bonus',
                    value: 500,  // Bonus points
                    duration: 0
                },
                {
                    id: 'sql_query',
                    label: 'SQL Query',
                    shortLabel: '+SQL',
                    color: 0x00ccff,
                    glowColor: '#00ccff',
                    shape: 'ribbon',
                    size: 16,
                    effect: 'clear',
                    value: 3,  // Clears 3 nearby enemies
                    duration: 0
                },
                {
                    id: 'api_connect',
                    label: 'API Connection',
                    shortLabel: '+API',
                    color: 0x00ffff,
                    glowColor: '#00ffff',
                    shape: 'connector',
                    size: 15,
                    effect: 'multiplier',
                    value: 2,  // 2x multiplier
                    duration: 5000  // 5 seconds
                }
            ]
        };

        // =====================================================
        // 2. STATE
        // =====================================================
        const state = {
            scroll: {
                y: 0,
                targetY: 0,
                progress: 0,
                currentChapter: 1,
                chapterProgress: 0
            },
            particles: {
                wasteDetected: 0,
                savingsUnlocked: 0,
                optimizing: false,
                captureCount: 0
            },
            hands: {
                enabled: false,
                left: null,
                right: null,
                leftGesture: 'idle',
                rightGesture: 'idle'
            },
            hud: {
                fps: 60,
                sqlQueries: 0
            },
            accessibility: {
                reduceMotion: false
            },
            timing: {
                lastTime: 0,
                deltaTime: 0,
                elapsed: 0,
                timeScale: 1
            },
            // NEW: Game Mode State
            gameMode: {
                active: false,
                state: 'idle', // idle, countdown, playing, ended, results
                timeRemaining: 30,
                score: 0,
                captures: 0,
                combo: {
                    current: 0,
                    multiplier: 1,
                    best: 0,
                    lastCaptureTime: 0,
                    meter: 0
                },
                rank: 'D'
            },
            // NEW: Calculator State
            calculator: {
                adSpend: 0,
                estimatedWaste: 0,
                analyzed: false,
                shown: false
            },
            // NEW: Audio State
            audio: {
                enabled: true,
                context: null,
                masterGain: null
            },
            // NEW: Achievements State
            achievements: {
                unlocked: new Set(),
                pending: []
            },
            // NEW: Easter Eggs State
            easterEggs: {
                godMode: false,
                konamiProgress: 0
            },
            // NEW: 3D Enemies State
            enemies: {
                active: [],  // Active enemy objects
                pool: [],    // Object pool for reuse
                maxCount: 12,
                spawnTimer: 0,
                spawnInterval: 2000  // ms between spawns
            },
            // NEW: Boost Pickups State
            boosts: {
                active: [],
                pool: [],
                maxCount: 4,
                spawnTimer: 0,
                spawnInterval: 5000,
                activeMultiplier: 1,
                multiplierEndTime: 0
            },
            // NEW: Hand Cursor (3D visual indicator)
            handCursor: {
                position: new THREE.Vector3(),
                targetPosition: new THREE.Vector3(),
                visible: false,
                captureRadius: 100,  // Larger radius for easier hits
                lastHitTime: 0
            },
            // Mouse world position for click detection
            mouseWorldPos: null
        };

        // =====================================================
        // 3. VIRAL ENGINE
        // =====================================================
        const ViralEngine = {
            // COMBO SYSTEM CONSTANTS
            COMBO: {
                WINDOW: 1500,
                THRESHOLDS: [3, 5, 10, 20],
                MULTIPLIERS: [2, 3, 5, 10]
            },

            // RANK THRESHOLDS
            RANKS: {
                S: 50000,
                A: 35000,
                B: 20000,
                C: 10000
            },

            // FAKE SQL QUERIES FOR ANALYSIS
            SQL_QUERIES: [
                "SELECT customer_id, COUNT(DISTINCT conversion_id) FROM amc_conversions...",
                "WITH attribution_paths AS (SELECT path, touchpoints FROM marketing_stream...",
                "ANALYZE frequency_cap WHERE impressions > threshold AND...",
                "SELECT keyword, overlap_percentage FROM cannibalization_analysis...",
                "COMPUTE incrementality_score FROM test_control_groups WHERE...",
                "JOIN audience_segments ON overlap_ratio > 0.3 WHERE waste_indicator...",
                "AGGREGATE placement_performance BY daypart, device_type WHERE ROAS <...",
                "WINDOW function over campaign_history PARTITION BY product_category..."
            ],

            // ACHIEVEMENTS DEFINITIONS
            ACHIEVEMENTS: {
                firstBlood: { name: 'First Blood', description: 'Crush first waste', icon: '&#127919;' },
                comboKing: { name: 'Combo King', description: '10x combo achieved', icon: '&#128081;' },
                efficiencyExpert: { name: 'Efficiency Expert', description: 'S rank achieved', icon: '&#11088;' },
                speedDemon: { name: 'Speed Demon', description: 'Clear all in 30s', icon: '&#9889;' },
                handMaster: { name: 'Hand Master', description: 'Use hand tracking', icon: '&#9995;' },
                ultimateWarrior: { name: 'Ultimate Warrior', description: 'Execute ultimate move', icon: '&#128165;' }
            },

            // KONAMI CODE
            KONAMI: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65],

            // =============== GAME MODE ===============
            GameMode: {
                gameInterval: null,

                start() {
                    state.gameMode.state = 'countdown';
                    state.gameMode.score = 0;
                    state.gameMode.captures = 0;
                    state.gameMode.combo = { current: 0, multiplier: 1, best: 0, lastCaptureTime: 0, meter: 0 };
                    state.gameMode.timeRemaining = 30;

                    // Scroll to top for clear play area (works on both desktop and mobile)
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    document.getElementById('scroll-container').scrollTo({ top: 0, behavior: 'smooth' });

                    // Hide regular HUD elements
                    document.querySelectorAll('.hud').forEach(h => h.style.opacity = '0.3');
                    document.getElementById('play-mode-btn').classList.add('hidden');
                    document.getElementById('cta-sticky').classList.add('hidden');
                    document.getElementById('scroll-container').style.pointerEvents = 'none';

                    // Hide all chapter content for clear play area
                    document.querySelectorAll('.chapter-content').forEach(c => {
                        c.style.transition = 'opacity 0.3s ease';
                        c.style.opacity = '0';
                        c.style.pointerEvents = 'none';
                    });

                    // Show countdown
                    this.showCountdown();
                },

                showCountdown() {
                    const overlay = document.getElementById('countdown-overlay');
                    const numberEl = document.getElementById('countdown-number');
                    overlay.classList.remove('hidden');

                    let count = 3;
                    numberEl.textContent = count;

                    const countInterval = setInterval(() => {
                        count--;
                        if (count > 0) {
                            numberEl.textContent = count;
                            numberEl.style.animation = 'none';
                            numberEl.offsetHeight; // Trigger reflow
                            numberEl.style.animation = 'countdownPop 1s ease-out';
                            ViralEngine.Audio.play('click');
                        } else {
                            clearInterval(countInterval);
                            overlay.classList.add('hidden');
                            this.beginGame();
                        }
                    }, 1000);

                    ViralEngine.Audio.play('click');
                },

                beginGame() {
                    state.gameMode.state = 'playing';
                    state.gameMode.active = true;

                    // Show game HUD
                    document.getElementById('game-hud').classList.remove('hidden');
                    this.updateGameHUD();

                    ViralEngine.Audio.play('success');

                    // Start timer
                    this.gameInterval = setInterval(() => {
                        state.gameMode.timeRemaining--;
                        this.updateGameHUD();

                        // Warning at 10 seconds
                        if (state.gameMode.timeRemaining <= 10) {
                            document.getElementById('game-timer').classList.add('warning');
                            ViralEngine.Audio.play('click');
                        }

                        if (state.gameMode.timeRemaining <= 0) {
                            this.endGame();
                        }
                    }, 1000);
                },

                endGame() {
                    clearInterval(this.gameInterval);
                    state.gameMode.state = 'ended';
                    state.gameMode.active = false;

                    // Calculate rank
                    state.gameMode.rank = this.calculateRank();

                    // Hide game HUD
                    document.getElementById('game-hud').classList.add('hidden');
                    document.getElementById('game-timer').classList.remove('warning');

                    // Check achievements
                    ViralEngine.Achievements.check('efficiencyExpert', state.gameMode.rank === 'S');

                    // Show results after brief delay
                    setTimeout(() => this.showResults(), 500);

                    ViralEngine.Audio.play('success');
                    if (state.gameMode.rank === 'S') {
                        ViralEngine.Effects.confetti();
                    }
                },

                calculateRank() {
                    const score = state.gameMode.score;
                    if (score >= ViralEngine.RANKS.S) return 'S';
                    if (score >= ViralEngine.RANKS.A) return 'A';
                    if (score >= ViralEngine.RANKS.B) return 'B';
                    if (score >= ViralEngine.RANKS.C) return 'C';
                    return 'D';
                },

                showResults() {
                    state.gameMode.state = 'results';
                    const resultsScreen = document.getElementById('results-screen');

                    // Update result values
                    document.getElementById('result-score').textContent = '$' + state.gameMode.score.toLocaleString();
                    document.getElementById('result-combo').textContent = state.gameMode.combo.best + 'x';
                    document.getElementById('result-captures').textContent = state.gameMode.captures;

                    // Update rank badge
                    const badge = document.getElementById('result-rank-badge');
                    badge.textContent = state.gameMode.rank;
                    badge.className = 'rank-badge rank-' + state.gameMode.rank;

                    resultsScreen.classList.remove('hidden');

                    // Generate share card
                    ViralEngine.Social.generateShareCard();
                },

                closeResults() {
                    document.getElementById('results-screen').classList.add('hidden');
                    state.gameMode.state = 'idle';

                    // Restore UI
                    document.querySelectorAll('.hud').forEach(h => h.style.opacity = '1');
                    document.getElementById('play-mode-btn').classList.remove('hidden');
                    document.getElementById('cta-sticky').classList.remove('hidden');
                    document.getElementById('scroll-container').style.pointerEvents = '';

                    // Restore chapter content visibility
                    document.querySelectorAll('.chapter-content').forEach(c => {
                        c.style.opacity = '1';
                        c.style.pointerEvents = '';
                    });
                },

                addScore(amount) {
                    if (!state.gameMode.active) return;

                    const multiplied = amount * state.gameMode.combo.multiplier;
                    state.gameMode.score += multiplied;
                    state.gameMode.captures++;
                    this.updateCombo();
                    this.updateGameHUD();

                    // Check first blood achievement
                    if (state.gameMode.captures === 1) {
                        ViralEngine.Achievements.check('firstBlood', true);
                    }

                    return multiplied;
                },

                updateCombo() {
                    const now = Date.now();
                    const timeSinceLast = now - state.gameMode.combo.lastCaptureTime;

                    if (timeSinceLast < ViralEngine.COMBO.WINDOW) {
                        state.gameMode.combo.current++;

                        // Check for multiplier upgrade
                        let newMultiplier = 1;
                        for (let i = ViralEngine.COMBO.THRESHOLDS.length - 1; i >= 0; i--) {
                            if (state.gameMode.combo.current >= ViralEngine.COMBO.THRESHOLDS[i]) {
                                newMultiplier = ViralEngine.COMBO.MULTIPLIERS[i];
                                break;
                            }
                        }

                        if (newMultiplier > state.gameMode.combo.multiplier) {
                            state.gameMode.combo.multiplier = newMultiplier;
                            ViralEngine.Audio.play('comboUp', newMultiplier);
                            document.getElementById('combo-multiplier').classList.add('level-up');
                            setTimeout(() => {
                                document.getElementById('combo-multiplier').classList.remove('level-up');
                            }, 300);

                            // Check combo king achievement
                            if (newMultiplier >= 10) {
                                ViralEngine.Achievements.check('comboKing', true);
                            }
                        }
                    } else {
                        state.gameMode.combo.current = 1;
                        state.gameMode.combo.multiplier = 1;
                    }

                    state.gameMode.combo.lastCaptureTime = now;
                    state.gameMode.combo.best = Math.max(state.gameMode.combo.best, state.gameMode.combo.multiplier);

                    // Update meter (progress to next threshold)
                    const nextThresholdIndex = ViralEngine.COMBO.THRESHOLDS.findIndex(t => t > state.gameMode.combo.current);
                    if (nextThresholdIndex >= 0) {
                        const prevThreshold = nextThresholdIndex > 0 ? ViralEngine.COMBO.THRESHOLDS[nextThresholdIndex - 1] : 0;
                        const nextThreshold = ViralEngine.COMBO.THRESHOLDS[nextThresholdIndex];
                        state.gameMode.combo.meter = (state.gameMode.combo.current - prevThreshold) / (nextThreshold - prevThreshold) * 100;
                    } else {
                        state.gameMode.combo.meter = 100;
                    }
                },

                updateGameHUD() {
                    document.getElementById('game-time').textContent = state.gameMode.timeRemaining;
                    document.getElementById('game-score').textContent = '$' + state.gameMode.score.toLocaleString();
                    document.getElementById('combo-multiplier').textContent = state.gameMode.combo.multiplier + 'x';
                    document.getElementById('combo-fill').style.width = state.gameMode.combo.meter + '%';
                }
            },

            // =============== AUDIO MANAGER ===============
            Audio: {
                init() {
                    try {
                        state.audio.context = new (window.AudioContext || window.webkitAudioContext)();
                        state.audio.masterGain = state.audio.context.createGain();
                        state.audio.masterGain.connect(state.audio.context.destination);
                        state.audio.masterGain.gain.value = 0.5;

                        // Resume on interaction
                        document.addEventListener('click', () => {
                            if (state.audio.context && state.audio.context.state === 'suspended') {
                                state.audio.context.resume();
                            }
                        }, { once: true });
                    } catch (e) {
                        state.audio.enabled = false;
                    }
                },

                play(soundName, ...args) {
                    if (!state.audio.enabled || !state.audio.context) return;
                    if (state.audio.context.state === 'suspended') {
                        state.audio.context.resume();
                    }

                    const ctx = state.audio.context;
                    const masterGain = state.audio.masterGain;

                    switch (soundName) {
                        case 'click':
                            this.playTone(1000, 0.05, 'sine', 0.1);
                            break;

                        case 'capture':
                            this.playNoise(0.1, 0.2);
                            this.playSweep(150, 50, 0.1, 'square', 0.2);
                            break;

                        case 'comboUp':
                            const level = args[0] || 1;
                            const freq = 440 * Math.pow(2, level / 6);
                            this.playTone(freq, 0.3, 'triangle', 0.15);
                            break;

                        case 'success':
                            [523, 659, 784, 1046].forEach((freq, i) => {
                                setTimeout(() => this.playTone(freq, 0.4, 'triangle', 0.12), i * 100);
                            });
                            break;

                        case 'ultimateBoom':
                            this.playSweep(80, 20, 0.5, 'sine', 0.6);
                            this.playNoise(0.6, 0.15);
                            break;

                        case 'sqlProcess':
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();
                            const filter = ctx.createBiquadFilter();

                            osc.type = 'sawtooth';
                            osc.frequency.value = 80;
                            filter.type = 'bandpass';
                            filter.frequency.value = 800;
                            filter.frequency.linearRampToValueAtTime(2000, ctx.currentTime + 0.2);
                            filter.Q.value = 10;
                            gain.gain.value = 0.08;
                            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.25);

                            osc.connect(filter);
                            filter.connect(gain);
                            gain.connect(masterGain);
                            osc.start();
                            osc.stop(ctx.currentTime + 0.25);
                            break;
                    }
                },

                playTone(freq, duration, type = 'sine', volume = 0.1) {
                    const ctx = state.audio.context;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = type;
                    osc.frequency.value = freq;
                    gain.gain.value = volume;
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(state.audio.masterGain);
                    osc.start();
                    osc.stop(ctx.currentTime + duration);
                },

                playSweep(startFreq, endFreq, duration, type = 'sine', volume = 0.1) {
                    const ctx = state.audio.context;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = type;
                    osc.frequency.value = startFreq;
                    osc.frequency.exponentialRampToValueAtTime(endFreq, ctx.currentTime + duration);
                    gain.gain.value = volume;
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(state.audio.masterGain);
                    osc.start();
                    osc.stop(ctx.currentTime + duration);
                },

                playNoise(duration, volume = 0.1) {
                    const ctx = state.audio.context;
                    const bufferSize = ctx.sampleRate * duration;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }

                    const source = ctx.createBufferSource();
                    const gain = ctx.createGain();
                    source.buffer = buffer;
                    gain.gain.value = volume;
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

                    source.connect(gain);
                    gain.connect(state.audio.masterGain);
                    source.start();
                },

                toggle() {
                    state.audio.enabled = !state.audio.enabled;
                    const btn = document.getElementById('sound-toggle');
                    btn.innerHTML = state.audio.enabled ? '&#128266;' : '&#128264;';
                    btn.classList.toggle('muted', !state.audio.enabled);
                    if (state.audio.masterGain) {
                        state.audio.masterGain.gain.value = state.audio.enabled ? 0.5 : 0;
                    }
                }
            },

            // =============== EFFECTS ===============
            Effects: {
                screenShake(intensity = 0.3) {
                    if (state.accessibility.reduceMotion) return;
                    this.shakeIntensity = intensity;
                },

                shakeIntensity: 0,

                updateShake() {
                    if (this.shakeIntensity > 0.01) {
                        const offsetX = (Math.random() - 0.5) * this.shakeIntensity * 15;
                        const offsetY = (Math.random() - 0.5) * this.shakeIntensity * 15;
                        camera.position.x += offsetX;
                        camera.position.y += offsetY;
                        this.shakeIntensity *= 0.9;
                    }
                },

                flash(color = '#ffffff', intensity = 0.3) {
                    if (state.accessibility.reduceMotion) return;
                    const flash = document.getElementById('flash-overlay');
                    flash.style.background = color;
                    flash.style.opacity = intensity;
                    flash.style.transition = 'none';

                    requestAnimationFrame(() => {
                        flash.style.transition = 'opacity 0.15s ease-out';
                        flash.style.opacity = 0;
                    });
                },

                numberPopup(worldPos, value) {
                    const popup = document.createElement('div');
                    popup.className = 'number-popup';
                    popup.textContent = '+$' + value.toLocaleString();

                    // Convert world to screen
                    const vector = worldPos.clone();
                    vector.project(camera);
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

                    popup.style.left = x + 'px';
                    popup.style.top = y + 'px';
                    document.body.appendChild(popup);

                    requestAnimationFrame(() => popup.classList.add('animate'));
                    setTimeout(() => popup.remove(), 800);
                },

                confettiParticles: [],
                confettiCanvas: null,
                confettiCtx: null,

                confetti(count = 100) {
                    if (state.accessibility.reduceMotion) return;

                    if (!this.confettiCanvas) {
                        this.confettiCanvas = document.getElementById('confetti-canvas');
                        this.confettiCanvas.width = window.innerWidth;
                        this.confettiCanvas.height = window.innerHeight;
                        this.confettiCtx = this.confettiCanvas.getContext('2d');
                    }

                    const colors = ['#00ffff', '#00ff88', '#ffcc00', '#ff6600', '#ffffff', '#ff3366'];

                    for (let i = 0; i < count; i++) {
                        this.confettiParticles.push({
                            x: window.innerWidth / 2,
                            y: window.innerHeight / 2,
                            vx: (Math.random() - 0.5) * 25,
                            vy: Math.random() * -20 - 5,
                            rotation: Math.random() * 360,
                            rotationSpeed: (Math.random() - 0.5) * 15,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            width: 8 + Math.random() * 10,
                            height: 4 + Math.random() * 6,
                            life: 1
                        });
                    }

                    if (!this.confettiAnimating) {
                        this.confettiAnimating = true;
                        this.animateConfetti();
                    }
                },

                animateConfetti() {
                    const ctx = this.confettiCtx;
                    ctx.clearRect(0, 0, this.confettiCanvas.width, this.confettiCanvas.height);

                    for (let i = this.confettiParticles.length - 1; i >= 0; i--) {
                        const p = this.confettiParticles[i];

                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.4;
                        p.rotation += p.rotationSpeed;
                        p.life -= 0.012;

                        if (p.life <= 0) {
                            this.confettiParticles.splice(i, 1);
                            continue;
                        }

                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation * Math.PI / 180);
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = p.color;
                        ctx.fillRect(-p.width / 2, -p.height / 2, p.width, p.height);
                        ctx.restore();
                    }

                    if (this.confettiParticles.length > 0) {
                        requestAnimationFrame(() => this.animateConfetti());
                    } else {
                        this.confettiAnimating = false;
                    }
                }
            },

            // =============== CALCULATOR ===============
            Calculator: {
                show() {
                    document.getElementById('calculator-overlay').classList.remove('hidden');
                    state.calculator.shown = true;
                },

                hide() {
                    document.getElementById('calculator-overlay').classList.add('hidden');
                },

                async analyze(adSpend) {
                    state.calculator.adSpend = adSpend;
                    this.hide();

                    const analysisOverlay = document.getElementById('analysis-overlay');
                    const progressBar = document.getElementById('analysis-progress');
                    const sqlScroll = document.getElementById('sql-scroll');
                    const counterSpend = document.getElementById('counter-spend');
                    const counterWaste = document.getElementById('counter-waste');

                    analysisOverlay.classList.remove('hidden');
                    sqlScroll.innerHTML = '';

                    // Estimate waste (15-30%)
                    const wastePercent = 0.15 + Math.random() * 0.15;
                    const estimatedWaste = Math.floor(adSpend * wastePercent);

                    // Pulse AI Core
                    if (aiCore) aiCore.pulseIntensity = 2;

                    // Animate progress
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += 1.5;
                        if (progress > 100) progress = 100;
                        progressBar.style.width = progress + '%';

                        // Update counters
                        const spendProgress = Math.min(progress * 1.2, 100);
                        counterSpend.textContent = '$' + Math.floor(adSpend * (spendProgress / 100)).toLocaleString();

                        const wasteProgress = Math.max(0, (progress - 40) * 1.67);
                        if (wasteProgress > 0) {
                            counterWaste.textContent = '$' + Math.floor(estimatedWaste * (wasteProgress / 100)).toLocaleString();
                        }

                        if (progress >= 100) {
                            clearInterval(progressInterval);
                        }
                    }, 50);

                    // Add SQL queries
                    for (let i = 0; i < ViralEngine.SQL_QUERIES.length; i++) {
                        await new Promise(r => setTimeout(r, 400));
                        const queryEl = document.createElement('div');
                        queryEl.className = 'sql-query';
                        queryEl.textContent = ViralEngine.SQL_QUERIES[i];
                        sqlScroll.appendChild(queryEl);
                        sqlScroll.scrollTop = sqlScroll.scrollHeight;
                        ViralEngine.Audio.play('sqlProcess');
                    }

                    await new Promise(r => setTimeout(r, 500));

                    state.calculator.estimatedWaste = estimatedWaste;
                    state.calculator.analyzed = true;

                    ViralEngine.Audio.play('success');
                    analysisOverlay.classList.add('hidden');

                    // Update waste detected in main state
                    state.particles.wasteDetected = estimatedWaste;
                    updateHUD();
                }
            },

            // =============== ACHIEVEMENTS ===============
            Achievements: {
                init() {
                    try {
                        const saved = localStorage.getItem('fameexpress_achievements');
                        if (saved) {
                            state.achievements.unlocked = new Set(JSON.parse(saved));
                        }
                    } catch (e) {}
                },

                check(id, condition) {
                    if (state.achievements.unlocked.has(id) || !condition) return false;

                    this.unlock(id);
                    return true;
                },

                unlock(id) {
                    if (state.achievements.unlocked.has(id)) return;

                    state.achievements.unlocked.add(id);

                    try {
                        localStorage.setItem('fameexpress_achievements',
                            JSON.stringify([...state.achievements.unlocked]));
                    } catch (e) {}

                    this.showNotification(id);
                    ViralEngine.Audio.play('success');
                },

                showNotification(id) {
                    const achievement = ViralEngine.ACHIEVEMENTS[id];
                    if (!achievement) return;

                    const notification = document.createElement('div');
                    notification.className = 'achievement-notification';
                    notification.innerHTML = `
                        <span class="achievement-icon">${achievement.icon}</span>
                        <div class="achievement-content">
                            <span class="achievement-label">ACHIEVEMENT UNLOCKED</span>
                            <span class="achievement-name">${achievement.name}</span>
                        </div>
                    `;

                    document.body.appendChild(notification);
                    requestAnimationFrame(() => notification.classList.add('show'));

                    setTimeout(() => {
                        notification.classList.remove('show');
                        setTimeout(() => notification.remove(), 500);
                    }, 3000);
                }
            },

            // =============== SOCIAL SHARING ===============
            Social: {
                generateShareCard() {
                    const canvas = document.getElementById('share-canvas');
                    const ctx = canvas.getContext('2d');

                    // Background
                    const gradient = ctx.createLinearGradient(0, 0, 1200, 630);
                    gradient.addColorStop(0, '#0a0a0f');
                    gradient.addColorStop(1, '#1a1a2e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 1200, 630);

                    // Grid overlay
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 1200; i += 40) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 630);
                        ctx.stroke();
                    }
                    for (let i = 0; i < 630; i += 40) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(1200, i);
                        ctx.stroke();
                    }

                    // Branding
                    ctx.font = 'bold 28px Inter, sans-serif';
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText('FAME EXPRESS', 50, 50);

                    // Main score
                    ctx.font = 'bold 96px JetBrains Mono, monospace';
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('$' + state.gameMode.score.toLocaleString(), 50, 250);

                    ctx.font = '28px Inter, sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText('WASTE CRUSHED IN 60 SECONDS', 50, 300);

                    // Rank badge
                    const rankColors = {
                        S: '#ffd700', A: '#00ff88', B: '#00ccff', C: '#888888', D: '#663333'
                    };
                    ctx.beginPath();
                    ctx.arc(1050, 200, 80, 0, Math.PI * 2);
                    ctx.fillStyle = rankColors[state.gameMode.rank] || '#666';
                    ctx.fill();
                    ctx.font = 'bold 72px JetBrains Mono, monospace';
                    ctx.fillStyle = state.gameMode.rank === 'S' ? '#000' : '#fff';
                    ctx.textAlign = 'center';
                    ctx.fillText(state.gameMode.rank, 1050, 225);
                    ctx.textAlign = 'left';

                    // Stats
                    ctx.font = '20px JetBrains Mono, monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText('Best Combo: ' + state.gameMode.combo.best + 'x', 50, 400);
                    ctx.fillText('Captures: ' + state.gameMode.captures, 300, 400);

                    // CTA
                    ctx.font = 'bold 24px Inter, sans-serif';
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText('Can you beat my score? fameexpress.com', 50, 580);
                },

                getShareText() {
                    return `I crushed $${state.gameMode.score.toLocaleString()} in wasted ad spend in 30 seconds!

&#127919; ${state.gameMode.combo.best}x Best Combo
&#11088; ${state.gameMode.rank} Rank

How much are YOU wasting on Amazon Ads?
fameexpress.com #AmazonAds #FameExpress`;
                },

                async copyToClipboard() {
                    const text = this.getShareText().replace(/&#\d+;/g, ''); // Remove HTML entities for plain text
                    try {
                        await navigator.clipboard.writeText(text);
                        this.showToast('Copied to clipboard!');
                    } catch (e) {
                        // Fallback
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        this.showToast('Copied to clipboard!');
                    }
                },

                shareToTwitter() {
                    const text = encodeURIComponent(
                        `I crushed $${state.gameMode.score.toLocaleString()} in wasted ad spend in 30 seconds! ${state.gameMode.combo.best}x combo, ${state.gameMode.rank} rank. Can you beat me? fameexpress.com #AmazonAds`
                    );
                    window.open(`https://twitter.com/intent/tweet?text=${text}`, '_blank', 'width=550,height=420');
                },

                showToast(message) {
                    const toast = document.createElement('div');
                    toast.className = 'toast';
                    toast.textContent = message;
                    document.body.appendChild(toast);

                    requestAnimationFrame(() => toast.classList.add('show'));

                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => toast.remove(), 300);
                    }, 2000);
                }
            },

            // =============== EASTER EGGS ===============
            EasterEggs: {
                init() {
                    document.addEventListener('keydown', (e) => this.checkKonami(e));

                    // Shake detection
                    if (window.DeviceMotionEvent) {
                        let lastShake = 0;
                        window.addEventListener('devicemotion', (e) => {
                            const acc = e.accelerationIncludingGravity;
                            if (!acc) return;

                            const magnitude = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2);
                            if (magnitude > 20 && Date.now() - lastShake > 1000) {
                                lastShake = Date.now();
                                this.triggerShake();
                            }
                        });
                    }
                },

                checkKonami(e) {
                    if (e.keyCode === ViralEngine.KONAMI[state.easterEggs.konamiProgress]) {
                        state.easterEggs.konamiProgress++;
                        if (state.easterEggs.konamiProgress === ViralEngine.KONAMI.length) {
                            this.activateGodMode();
                            state.easterEggs.konamiProgress = 0;
                        }
                    } else {
                        state.easterEggs.konamiProgress = 0;
                    }
                },

                activateGodMode() {
                    state.easterEggs.godMode = true;
                    state.gameMode.combo.multiplier = 999;

                    document.body.classList.add('god-mode');

                    const notification = document.createElement('div');
                    notification.className = 'god-mode-notification';
                    notification.innerHTML = '<span>&#127775;</span><span>GOD MODE</span><span>&#127775;</span>';
                    document.body.appendChild(notification);

                    ViralEngine.Audio.play('success');
                    ViralEngine.Effects.confetti(200);

                    setTimeout(() => notification.remove(), 3000);
                },

                triggerShake() {
                    // Scatter all particles
                    if (!particleSystem) return;

                    for (let i = 0; i < particleSystem.count; i++) {
                        const i3 = i * 3;
                        particleSystem.velocities[i3] += (Math.random() - 0.5) * 15;
                        particleSystem.velocities[i3 + 1] += Math.random() * 15;
                        particleSystem.velocities[i3 + 2] += (Math.random() - 0.5) * 8;
                    }

                    ViralEngine.Audio.play('ultimateBoom');
                    ViralEngine.Effects.screenShake(0.6);

                    // Haptic
                    if (navigator.vibrate) {
                        navigator.vibrate([30, 20, 50, 20, 30]);
                    }
                }
            },

            // =============== TOUCH HANDLER ===============
            Touch: {
                touches: {},
                lastPinchDist: 0,

                init() {
                    const canvas = document.getElementById('main-canvas');

                    canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                    canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                    canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: true });
                },

                onTouchStart(e) {
                    if (e.target.closest('button, input, select, textarea, label, a, .form-panel')) return;
                    e.preventDefault();

                    for (const touch of e.changedTouches) {
                        this.touches[touch.identifier] = {
                            startX: touch.clientX,
                            startY: touch.clientY,
                            startTime: Date.now(),
                            lastX: touch.clientX,
                            lastY: touch.clientY,
                            trail: [{ x: touch.clientX, y: touch.clientY }]
                        };
                    }

                    if (e.touches.length === 2) {
                        this.lastPinchDist = this.getPinchDistance(e.touches);
                    }
                },

                onTouchMove(e) {
                    if (e.target.closest('button, input, select, textarea, label, a, .form-panel')) return;
                    e.preventDefault();

                    // Pinch detection
                    if (e.touches.length === 2) {
                        const dist = this.getPinchDistance(e.touches);
                        if (this.lastPinchDist - dist > 30) {
                            triggerOptimization();
                            this.lastPinchDist = dist;
                            this.haptic('medium');
                        }
                        return;
                    }

                    // Swipe through waste
                    for (const touch of e.changedTouches) {
                        const t = this.touches[touch.identifier];
                        if (!t) continue;

                        t.lastX = touch.clientX;
                        t.lastY = touch.clientY;
                        t.trail.push({ x: touch.clientX, y: touch.clientY });

                        if (t.trail.length > 15) t.trail.shift();

                        // Calculate swipe speed
                        const speed = this.getSwipeSpeed(t);
                        if (speed > 3) {
                            this.captureAlongTrail(t.trail);
                            this.haptic('light');
                        }
                    }
                },

                onTouchEnd(e) {
                    for (const touch of e.changedTouches) {
                        const t = this.touches[touch.identifier];
                        if (t) {
                            const speed = this.getSwipeSpeed(t);
                            if (speed > 2 && t.trail.length > 3) {
                                this.captureAlongTrail(t.trail);
                                this.haptic('medium');
                            }
                        }
                        delete this.touches[touch.identifier];
                    }
                },

                getPinchDistance(touches) {
                    return Math.hypot(
                        touches[0].clientX - touches[1].clientX,
                        touches[0].clientY - touches[1].clientY
                    );
                },

                getSwipeSpeed(t) {
                    if (t.trail.length < 2) return 0;
                    const recent = t.trail.slice(-5);
                    let dist = 0;
                    for (let i = 1; i < recent.length; i++) {
                        dist += Math.hypot(recent[i].x - recent[i-1].x, recent[i].y - recent[i-1].y);
                    }
                    return dist / recent.length;
                },

                captureAlongTrail(trail) {
                    // Simplified: trigger optimization effect
                    triggerOptimization();
                },

                haptic(type) {
                    if (!navigator.vibrate) return;
                    const patterns = {
                        light: [10],
                        medium: [20, 10, 20],
                        heavy: [30, 20, 50]
                    };
                    navigator.vibrate(patterns[type] || patterns.light);
                }
            }
        };

        // =====================================================
        // 4. THREE.JS GLOBALS
        // =====================================================
        let scene, camera, renderer;
        let particleSystem, aiCore;
        let enemyManager, boostManager, handCursorManager;
        let animationId;

        // =====================================================
        // 4A. ENEMY MANAGER - Distinct 3D enemies
        // =====================================================
        class EnemyManager {
            constructor() {
                this.enemies = [];
                this.group = new THREE.Group();
                this.hitLabelContainer = document.createElement('div');
                this.hitLabelContainer.id = 'hit-labels';
                this.hitLabelContainer.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:600;';
                document.body.appendChild(this.hitLabelContainer);
            }

            createEnemy(typeConfig) {
                const enemy = {
                    type: typeConfig,
                    mesh: null,
                    glowMesh: null,
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    health: typeConfig.id === 'increment' ? 2 : 1,
                    phase: Math.random() * Math.PI * 2,
                    age: 0,
                    active: true
                };

                // Create mesh based on shape - BRIGHT NEON with additive glow
                const group = new THREE.Group();

                // Helper to create glowing material
                const createGlowMat = (color, opacity = 1) => {
                    return new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: opacity,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                };

                switch(typeConfig.shape) {
                    case 'cube': {
                        const geo = new THREE.BoxGeometry(typeConfig.size, typeConfig.size, typeConfig.size);
                        enemy.mesh = new THREE.Mesh(geo, createGlowMat(typeConfig.color, 0.9));
                        // Bright wireframe
                        const wire = new THREE.Mesh(geo.clone(), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }));
                        wire.scale.setScalar(1.05);
                        group.add(wire);
                        break;
                    }
                    case 'rings': {
                        const torusGeo = new THREE.TorusGeometry(typeConfig.size * 0.6, 4, 8, 24);
                        enemy.mesh = new THREE.Group();
                        for (let i = 0; i < 3; i++) {
                            const ring = new THREE.Mesh(torusGeo, createGlowMat(typeConfig.color, 0.8));
                            ring.rotation.x = Math.PI / 2 + (i - 1) * 0.4;
                            ring.rotation.y = (i - 1) * 0.3;
                            enemy.mesh.add(ring);
                        }
                        break;
                    }
                    case 'pulse': {
                        const sphereGeo = new THREE.SphereGeometry(typeConfig.size * 0.7, 16, 12);
                        enemy.mesh = new THREE.Mesh(sphereGeo, createGlowMat(typeConfig.color, 0.85));
                        // Bright inner core
                        const core = new THREE.Mesh(
                            new THREE.SphereGeometry(typeConfig.size * 0.35, 8, 8),
                            createGlowMat(0xffffff, 0.9)
                        );
                        group.add(core);
                        break;
                    }
                    case 'chomper': {
                        enemy.mesh = new THREE.Group();
                        const halfGeo = new THREE.SphereGeometry(typeConfig.size * 0.6, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                        const topHalf = new THREE.Mesh(halfGeo, createGlowMat(typeConfig.color, 0.9));
                        const bottomHalf = new THREE.Mesh(halfGeo.clone(), createGlowMat(typeConfig.color, 0.9));
                        bottomHalf.rotation.x = Math.PI;
                        topHalf.name = 'top';
                        bottomHalf.name = 'bottom';
                        enemy.mesh.add(topHalf, bottomHalf);
                        // Add teeth (white)
                        const teethGeo = new THREE.ConeGeometry(3, 8, 4);
                        for (let i = 0; i < 4; i++) {
                            const tooth = new THREE.Mesh(teethGeo, createGlowMat(0xffffff, 0.8));
                            tooth.position.set(Math.cos(i * Math.PI/2) * 8, 0, Math.sin(i * Math.PI/2) * 8);
                            tooth.rotation.x = Math.PI;
                            enemy.mesh.add(tooth);
                        }
                        break;
                    }
                    case 'fragment': {
                        enemy.mesh = new THREE.Group();
                        for (let i = 0; i < 6; i++) {
                            const fragGeo = new THREE.TetrahedronGeometry(typeConfig.size * 0.35);
                            const frag = new THREE.Mesh(fragGeo, createGlowMat(typeConfig.color, 0.85));
                            frag.position.set(
                                (Math.random() - 0.5) * typeConfig.size * 0.8,
                                (Math.random() - 0.5) * typeConfig.size * 0.8,
                                (Math.random() - 0.5) * typeConfig.size * 0.4
                            );
                            frag.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                            frag.userData.basePos = frag.position.clone();
                            enemy.mesh.add(frag);
                        }
                        break;
                    }
                    case 'clock': {
                        const clockGeo = new THREE.CircleGeometry(typeConfig.size * 0.8, 24);
                        enemy.mesh = new THREE.Mesh(clockGeo, createGlowMat(typeConfig.color, 0.85));
                        enemy.mesh.material.side = THREE.DoubleSide;
                        // Clock rim
                        const rimGeo = new THREE.TorusGeometry(typeConfig.size * 0.8, 2, 8, 24);
                        const rim = new THREE.Mesh(rimGeo, createGlowMat(0xffffff, 0.8));
                        rim.rotation.x = Math.PI / 2;
                        group.add(rim);
                        // Clock hands
                        const handGeo = new THREE.PlaneGeometry(3, typeConfig.size * 0.6);
                        const hand = new THREE.Mesh(handGeo, createGlowMat(0xffffff, 1));
                        hand.position.y = typeConfig.size * 0.3;
                        hand.name = 'hand';
                        const handGroup = new THREE.Group();
                        handGroup.add(hand);
                        enemy.mesh.add(handGroup);
                        break;
                    }
                    default: {
                        const geo = new THREE.OctahedronGeometry(typeConfig.size * 0.7);
                        enemy.mesh = new THREE.Mesh(geo, createGlowMat(typeConfig.color, 0.9));
                    }
                }

                group.add(enemy.mesh);

                // BRIGHT inner core for ALL enemies
                const coreGeo = new THREE.SphereGeometry(typeConfig.size * 0.3, 8, 8);
                const coreMesh = new THREE.Mesh(coreGeo, createGlowMat(0xffffff, 1));
                group.add(coreMesh);

                // Outer glow sphere - ADDITIVE for bright neon effect
                const glowGeo = new THREE.SphereGeometry(typeConfig.size * 1.8, 12, 12);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: typeConfig.color,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                enemy.glowMesh = new THREE.Mesh(glowGeo, glowMat);
                group.add(enemy.glowMesh);

                // Second outer glow for extra pop
                const glow2Geo = new THREE.SphereGeometry(typeConfig.size * 2.5, 8, 8);
                const glow2Mat = new THREE.MeshBasicMaterial({
                    color: typeConfig.color,
                    transparent: true,
                    opacity: 0.25,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                group.add(new THREE.Mesh(glow2Geo, glow2Mat));

                enemy.group = group;

                // Position in play area
                const area = CONFIG.playArea;
                enemy.position.set(
                    area.minX + Math.random() * (area.maxX - area.minX),
                    area.minY + Math.random() * (area.maxY - area.minY),
                    area.minZ + Math.random() * (area.maxZ - area.minZ)
                );
                group.position.copy(enemy.position);

                // Initial velocity based on behavior
                this.setVelocityForBehavior(enemy);

                return enemy;
            }

            setVelocityForBehavior(enemy) {
                const speed = 0.3 + Math.random() * 0.4;
                switch(enemy.type.behavior) {
                    case 'drift':
                        enemy.velocity.set(speed, 0, 0);
                        break;
                    case 'orbit':
                        enemy.velocity.set(0, speed, 0);
                        enemy.orbitCenter = enemy.position.clone();
                        enemy.orbitRadius = 30 + Math.random() * 30;
                        break;
                    case 'pulse':
                        enemy.velocity.set((Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed, 0);
                        break;
                    case 'chase':
                        enemy.velocity.set(0, 0, 0);
                        break;
                    case 'split':
                        enemy.velocity.set((Math.random() - 0.5) * speed * 0.5, (Math.random() - 0.5) * speed * 0.5, 0);
                        break;
                    case 'zigzag':
                        enemy.velocity.set(speed, 0, 0);
                        enemy.zigzagTimer = 0;
                        break;
                    default:
                        enemy.velocity.set((Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed, 0);
                }
            }

            spawn() {
                if (this.enemies.length >= state.enemies.maxCount) return null;

                const typeIndex = Math.floor(Math.random() * CONFIG.enemyTypes.length);
                const typeConfig = CONFIG.enemyTypes[typeIndex];
                const enemy = this.createEnemy(typeConfig);

                this.enemies.push(enemy);
                this.group.add(enemy.group);

                return enemy;
            }

            update(deltaTime, time) {
                const area = CONFIG.playArea;

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    if (!enemy.active) continue;

                    enemy.age += deltaTime;

                    // Behavior-specific updates
                    switch(enemy.type.behavior) {
                        case 'orbit':
                            if (enemy.orbitCenter) {
                                const angle = time * 0.5 + enemy.phase;
                                enemy.position.x = enemy.orbitCenter.x + Math.cos(angle) * enemy.orbitRadius;
                                enemy.position.y = enemy.orbitCenter.y + Math.sin(angle) * enemy.orbitRadius;
                            }
                            break;
                        case 'pulse':
                            const pulseScale = 1 + Math.sin(time * 3 + enemy.phase) * 0.3;
                            enemy.mesh.scale.setScalar(pulseScale);
                            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime * 60));
                            break;
                        case 'chomper':
                            // Animate chomping
                            const chompAngle = Math.abs(Math.sin(time * 4 + enemy.phase)) * 0.4;
                            if (enemy.mesh.children) {
                                enemy.mesh.children.forEach(child => {
                                    if (child.name === 'top') child.position.y = chompAngle * 5;
                                    if (child.name === 'bottom') child.position.y = -chompAngle * 5;
                                });
                            }
                            // Chase nearest other enemy
                            let nearest = null;
                            let nearestDist = 150;
                            for (const other of this.enemies) {
                                if (other === enemy || !other.active) continue;
                                const dist = enemy.position.distanceTo(other.position);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearest = other;
                                }
                            }
                            if (nearest) {
                                const dir = nearest.position.clone().sub(enemy.position).normalize();
                                enemy.velocity.lerp(dir.multiplyScalar(0.5), 0.02);
                            }
                            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime * 60));
                            break;
                        case 'fragment':
                            // Floating fragments
                            if (enemy.mesh.children) {
                                enemy.mesh.children.forEach((frag, idx) => {
                                    if (frag.userData.basePos) {
                                        frag.position.copy(frag.userData.basePos);
                                        frag.position.y += Math.sin(time * 2 + idx) * 3;
                                    }
                                    frag.rotation.x += deltaTime * 0.5;
                                    frag.rotation.y += deltaTime * 0.3;
                                });
                            }
                            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime * 60));
                            break;
                        case 'clock':
                            // Rotate clock hand
                            if (enemy.mesh.children && enemy.mesh.children[0]) {
                                enemy.mesh.children[0].rotation.z = -time * 2;
                            }
                            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime * 60));
                            break;
                        case 'zigzag':
                            enemy.zigzagTimer = (enemy.zigzagTimer || 0) + deltaTime;
                            if (enemy.zigzagTimer > 0.5) {
                                enemy.zigzagTimer = 0;
                                enemy.velocity.y = -enemy.velocity.y || ((Math.random() - 0.5) * 0.6);
                            }
                            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime * 60));
                            break;
                        default:
                            enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime * 60));
                    }

                    // Rotate mesh
                    enemy.mesh.rotation.y += deltaTime * 0.5;
                    enemy.mesh.rotation.x += deltaTime * 0.2;

                    // Pulse glow
                    if (enemy.glowMesh) {
                        enemy.glowMesh.material.opacity = 0.1 + Math.sin(time * 2 + enemy.phase) * 0.08;
                    }

                    // Bounce off bounds
                    if (enemy.position.x < area.minX || enemy.position.x > area.maxX) {
                        enemy.velocity.x *= -1;
                        enemy.position.x = Math.max(area.minX, Math.min(area.maxX, enemy.position.x));
                    }
                    if (enemy.position.y < area.minY || enemy.position.y > area.maxY) {
                        enemy.velocity.y *= -1;
                        enemy.position.y = Math.max(area.minY, Math.min(area.maxY, enemy.position.y));
                    }

                    enemy.group.position.copy(enemy.position);
                }
            }

            checkHit(worldPos, radius = 100) {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    if (!enemy.active) continue;

                    // Use X/Y distance only (ignore Z) for hand tracking
                    const dx = enemy.position.x - worldPos.x;
                    const dy = enemy.position.y - worldPos.y;
                    const dist2D = Math.sqrt(dx * dx + dy * dy);

                    if (dist2D < radius + enemy.type.size) {
                        return this.hitEnemy(enemy, i);
                    }
                }
                return null;
            }

            hitEnemy(enemy, index) {
                enemy.health--;

                if (enemy.health <= 0) {
                    // Destroy enemy
                    enemy.active = false;
                    this.group.remove(enemy.group);
                    this.enemies.splice(index, 1);

                    // Show hit label
                    this.showHitLabel(enemy);

                    return {
                        destroyed: true,
                        type: enemy.type,
                        points: enemy.type.points,
                        position: enemy.position.clone()
                    };
                } else {
                    // Damaged but not destroyed (incrementality gap)
                    // Flash effect
                    if (enemy.mesh.material) {
                        enemy.mesh.material.color.setHex(0xffffff);
                        setTimeout(() => {
                            if (enemy.mesh.material) enemy.mesh.material.color.setHex(enemy.type.color);
                        }, 100);
                    }
                    return {
                        destroyed: false,
                        type: enemy.type,
                        points: Math.floor(enemy.type.points / 2),
                        position: enemy.position.clone()
                    };
                }
            }

            showHitLabel(enemy) {
                // Project 3D position to screen
                const pos = enemy.position.clone();
                pos.project(camera);
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

                const label = document.createElement('div');
                label.className = 'enemy-hit-label';
                label.innerHTML = `<span class="hit-type">${enemy.type.shortLabel}</span><span class="hit-value">${enemy.type.value}</span>`;
                label.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    transform: translate(-50%, -50%);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 14px;
                    font-weight: 700;
                    color: ${enemy.type.glowColor};
                    text-shadow: 0 0 10px ${enemy.type.glowColor}, 0 0 20px ${enemy.type.glowColor};
                    text-align: center;
                    animation: hitLabelPop 0.8s ease-out forwards;
                    pointer-events: none;
                    z-index: 650;
                `;
                this.hitLabelContainer.appendChild(label);

                setTimeout(() => label.remove(), 800);
            }

            clear() {
                for (const enemy of this.enemies) {
                    this.group.remove(enemy.group);
                }
                this.enemies = [];
            }
        }

        // =====================================================
        // 4B. BOOST MANAGER - Positive pickups
        // =====================================================
        class BoostManager {
            constructor() {
                this.boosts = [];
                this.group = new THREE.Group();
            }

            createBoost(typeConfig) {
                const boost = {
                    type: typeConfig,
                    mesh: null,
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    phase: Math.random() * Math.PI * 2,
                    active: true
                };

                const group = new THREE.Group();

                // Helper for bright additive material
                const createBoostMat = (color, opacity = 1) => {
                    return new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: opacity,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                };

                switch(typeConfig.shape) {
                    case 'diamond': {
                        const geo = new THREE.OctahedronGeometry(typeConfig.size * 0.8);
                        boost.mesh = new THREE.Mesh(geo, createBoostMat(typeConfig.color, 0.9));
                        break;
                    }
                    case 'ribbon': {
                        const curve = new THREE.CatmullRomCurve3([
                            new THREE.Vector3(-typeConfig.size, 0, 0),
                            new THREE.Vector3(0, typeConfig.size * 0.5, 0),
                            new THREE.Vector3(typeConfig.size, 0, 0)
                        ]);
                        const tubeGeo = new THREE.TubeGeometry(curve, 20, 3, 8, false);
                        boost.mesh = new THREE.Mesh(tubeGeo, createBoostMat(typeConfig.color, 0.9));
                        break;
                    }
                    case 'connector': {
                        boost.mesh = new THREE.Group();
                        const cylGeo = new THREE.CylinderGeometry(typeConfig.size * 0.35, typeConfig.size * 0.35, typeConfig.size * 1.2, 8);
                        const cyl = new THREE.Mesh(cylGeo, createBoostMat(typeConfig.color, 0.9));
                        cyl.rotation.z = Math.PI / 2;
                        const capGeo = new THREE.SphereGeometry(typeConfig.size * 0.5, 8, 8);
                        const cap1 = new THREE.Mesh(capGeo, createBoostMat(0xffffff, 0.9));
                        const cap2 = cap1.clone();
                        cap1.position.x = -typeConfig.size * 0.6;
                        cap2.position.x = typeConfig.size * 0.6;
                        boost.mesh.add(cyl, cap1, cap2);
                        break;
                    }
                    default: {
                        const geo = new THREE.DodecahedronGeometry(typeConfig.size * 0.6);
                        boost.mesh = new THREE.Mesh(geo, createBoostMat(typeConfig.color, 0.9));
                    }
                }

                group.add(boost.mesh);

                // Bright inner core
                const coreGeo = new THREE.SphereGeometry(typeConfig.size * 0.3, 8, 8);
                group.add(new THREE.Mesh(coreGeo, createBoostMat(0xffffff, 1)));

                // Outer glow with additive blending
                const glowGeo = new THREE.SphereGeometry(typeConfig.size * 2, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: typeConfig.color,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                boost.glowMesh = new THREE.Mesh(glowGeo, glowMat);
                group.add(boost.glowMesh);

                // Second glow layer
                const glow2Geo = new THREE.SphereGeometry(typeConfig.size * 2.8, 8, 8);
                group.add(new THREE.Mesh(glow2Geo, new THREE.MeshBasicMaterial({
                    color: typeConfig.color,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })));

                boost.group = group;

                // Position
                const area = CONFIG.playArea;
                boost.position.set(
                    area.minX + Math.random() * (area.maxX - area.minX),
                    area.minY + Math.random() * (area.maxY - area.minY),
                    (area.minZ + area.maxZ) / 2 + (Math.random() - 0.5) * 100
                );
                group.position.copy(boost.position);

                boost.velocity.set((Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, 0);

                return boost;
            }

            spawn() {
                if (this.boosts.length >= state.boosts.maxCount) return null;

                const typeIndex = Math.floor(Math.random() * CONFIG.boostTypes.length);
                const typeConfig = CONFIG.boostTypes[typeIndex];
                const boost = this.createBoost(typeConfig);

                this.boosts.push(boost);
                this.group.add(boost.group);

                return boost;
            }

            update(deltaTime, time) {
                const area = CONFIG.playArea;

                for (const boost of this.boosts) {
                    if (!boost.active) continue;

                    // Float/bob motion
                    boost.mesh.rotation.y += deltaTime;
                    boost.mesh.position.y = Math.sin(time * 2 + boost.phase) * 5;

                    // Gentle drift
                    boost.position.add(boost.velocity.clone().multiplyScalar(deltaTime * 60));

                    // Bounce
                    if (boost.position.x < area.minX || boost.position.x > area.maxX) {
                        boost.velocity.x *= -1;
                    }
                    if (boost.position.y < area.minY || boost.position.y > area.maxY) {
                        boost.velocity.y *= -1;
                    }

                    // Pulse glow
                    boost.glowMesh.material.opacity = 0.15 + Math.sin(time * 3 + boost.phase) * 0.1;

                    boost.group.position.copy(boost.position);
                }
            }

            checkHit(worldPos, radius = 60) {
                for (let i = this.boosts.length - 1; i >= 0; i--) {
                    const boost = this.boosts[i];
                    if (!boost.active) continue;

                    const dist = boost.position.distanceTo(worldPos);
                    if (dist < radius + boost.type.size) {
                        return this.collectBoost(boost, i);
                    }
                }
                return null;
            }

            collectBoost(boost, index) {
                boost.active = false;
                this.group.remove(boost.group);
                this.boosts.splice(index, 1);

                return {
                    type: boost.type,
                    effect: boost.type.effect,
                    value: boost.type.value,
                    duration: boost.type.duration,
                    position: boost.position.clone()
                };
            }

            clear() {
                for (const boost of this.boosts) {
                    this.group.remove(boost.group);
                }
                this.boosts = [];
            }
        }

        // =====================================================
        // 4C. HAND CURSOR - Visual indicator for hand position
        // =====================================================
        class HandCursorManager {
            constructor() {
                this.group = new THREE.Group();
                this.visible = false;

                // Outer ring (capture radius indicator)
                const ringGeo = new THREE.RingGeometry(55, 60, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.ring.rotation.x = -Math.PI / 2;

                // Center reticle
                const reticleGeo = new THREE.CircleGeometry(8, 16);
                const reticleMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                this.reticle = new THREE.Mesh(reticleGeo, reticleMat);
                this.reticle.rotation.x = -Math.PI / 2;

                // Cross lines
                const lineGeo = new THREE.PlaneGeometry(100, 2);
                const lineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                this.lineH = new THREE.Mesh(lineGeo, lineMat);
                this.lineV = new THREE.Mesh(lineGeo.clone(), lineMat.clone());
                this.lineH.rotation.x = -Math.PI / 2;
                this.lineV.rotation.x = -Math.PI / 2;
                this.lineV.rotation.z = Math.PI / 2;

                this.group.add(this.ring, this.reticle, this.lineH, this.lineV);
                this.group.visible = false;

                // Gesture indicator text element
                this.gestureLabel = document.createElement('div');
                this.gestureLabel.id = 'gesture-label';
                this.gestureLabel.style.cssText = `
                    position: fixed;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 12px;
                    font-weight: 700;
                    color: #00ffff;
                    text-shadow: 0 0 10px #00ffff;
                    pointer-events: none;
                    z-index: 500;
                    opacity: 0;
                    transition: opacity 0.2s;
                `;
                document.body.appendChild(this.gestureLabel);
            }

            setPosition(worldPos) {
                this.group.position.copy(worldPos);
                this.group.visible = true;
                this.visible = true;

                // Update screen position for label
                const screenPos = worldPos.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                this.gestureLabel.style.left = `${x}px`;
                this.gestureLabel.style.top = `${y + 80}px`;
                this.gestureLabel.style.transform = 'translateX(-50%)';
            }

            setGesture(gesture) {
                const labels = {
                    'idle': '',
                    'capture': 'OPEN PALM - ATTRACT',
                    'execute': 'PINCH - STRIKE'
                };
                this.gestureLabel.textContent = labels[gesture] || '';
                this.gestureLabel.style.opacity = gesture !== 'idle' ? '1' : '0';

                // Change color based on gesture
                const colors = {
                    'idle': 0x00ffff,
                    'capture': 0x00ff88,
                    'execute': 0xffaa00
                };
                const color = colors[gesture] || 0x00ffff;
                this.ring.material.color.setHex(color);
                this.reticle.material.color.setHex(color);
            }

            pulseHit() {
                // Flash effect on hit
                this.ring.material.opacity = 1;
                this.reticle.scale.setScalar(2);
                setTimeout(() => {
                    this.ring.material.opacity = 0.4;
                    this.reticle.scale.setScalar(1);
                }, 150);
            }

            hide() {
                this.group.visible = false;
                this.visible = false;
                this.gestureLabel.style.opacity = '0';
            }

            update(time) {
                if (!this.visible) return;

                // Rotate ring slowly
                this.ring.rotation.z = time * 0.5;

                // Pulse reticle
                const pulse = 1 + Math.sin(time * 4) * 0.1;
                this.reticle.scale.setScalar(pulse);
            }
        }

        // =====================================================
        // 4. PARTICLE SYSTEM CLASS
        // =====================================================
        class ParticleSystem {
            constructor(count) {
                this.count = count;
                this.geometry = new THREE.BufferGeometry();

                // Buffers
                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);
                this.colors = new Float32Array(count * 3);
                this.sizes = new Float32Array(count);
                this.alphas = new Float32Array(count);
                this.species = new Uint8Array(count);
                this.phases = new Float32Array(count);
                this.clusterIds = new Int16Array(count).fill(-1);

                this.anomalyClusters = [];  // Kept for compatibility, but enemies are now 3D objects
                this.handForces = { left: null, right: null };

                this.initParticles();
                this.setupGeometry();
                this.createMaterial();
                // Note: Enemies are now handled by EnemyManager as 3D objects
            }

            initParticles() {
                const spendEnd = Math.floor(this.count * CONFIG.particles.species.spend.ratio);
                const wasteEnd = spendEnd + Math.floor(this.count * CONFIG.particles.species.waste.ratio);

                const streamWidth = 600;
                const streamHeight = 250;
                // Particles in BACKGROUND (negative Z, far from camera) - EXPANDED DEPTH RANGE
                const streamZMin = -800;  // Far back (extended)
                const streamZMax = -100;  // Closer to camera (extended)

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;

                    // Assign species
                    if (i < spendEnd) {
                        this.species[i] = 0;
                        this.colors[i3] = CONFIG.particles.species.spend.color[0];
                        this.colors[i3 + 1] = CONFIG.particles.species.spend.color[1];
                        this.colors[i3 + 2] = CONFIG.particles.species.spend.color[2];
                    } else if (i < wasteEnd) {
                        this.species[i] = 1;
                        this.colors[i3] = CONFIG.particles.species.waste.color[0];
                        this.colors[i3 + 1] = CONFIG.particles.species.waste.color[1];
                        this.colors[i3 + 2] = CONFIG.particles.species.waste.color[2];
                    } else {
                        this.species[i] = 2;
                        this.colors[i3] = CONFIG.particles.species.profit.color[0];
                        this.colors[i3 + 1] = CONFIG.particles.species.profit.color[1];
                        this.colors[i3 + 2] = CONFIG.particles.species.profit.color[2];
                    }

                    // Initialize positions - BACKGROUND LAYER with depth variation
                    const z = streamZMin + Math.random() * (streamZMax - streamZMin);
                    this.positions[i3] = (Math.random() - 0.5) * streamWidth * 2;

                    // Y distribution varies by depth for layered effect
                    const zNorm = (z + 800) / 700; // 0 (far) to 1 (near)
                    const ySpread = 150 + zNorm * 100; // Far particles more spread vertically
                    this.positions[i3 + 1] = (Math.random() - 0.5) * ySpread;
                    this.positions[i3 + 2] = z;

                    // Calculate depth factor for size and alpha
                    const depth = Math.abs(z);
                    const depthFactor = 1 - (depth - 100) / 700; // 0 (far) to 1 (near)

                    // Initial velocity (rightward flow) with subtle Z movement for parallax
                    this.velocities[i3] = CONFIG.physics.streamSpeed * (0.8 + Math.random() * 0.4);
                    this.velocities[i3 + 1] = 0;
                    this.velocities[i3 + 2] = (Math.random() - 0.5) * 0.5 * (1 - depthFactor); // Far particles move more in Z

                    // Visual attributes - depth-based sizing and brightness
                    this.sizes[i] = 1.5 + depthFactor * 4.5; // Range: 1.5 (far) to 6 (near)
                    this.alphas[i] = 0.4 + depthFactor * 0.6; // Range: 0.4 (far) to 1.0 (near)
                    this.phases[i] = Math.random() * Math.PI * 2;
                }
            }

            createAnomalyClusters() {
                // Create 6 waste clusters at different positions
                const clusterPositions = [
                    { x: -300, y: 50, z: 0 },
                    { x: -100, y: -60, z: 20 },
                    { x: 100, y: 70, z: -10 },
                    { x: 250, y: -40, z: 30 },
                    { x: -200, y: -20, z: -20 },
                    { x: 350, y: 30, z: 10 }
                ];

                let wasteIndex = Math.floor(this.count * CONFIG.particles.species.spend.ratio);
                const wasteEnd = wasteIndex + Math.floor(this.count * CONFIG.particles.species.waste.ratio);
                const particlesPerCluster = Math.floor((wasteEnd - wasteIndex) * 0.6 / clusterPositions.length);

                clusterPositions.forEach((pos, idx) => {
                    const cluster = {
                        id: idx,
                        center: new THREE.Vector3(pos.x, pos.y, pos.z),
                        radius: 40 + Math.random() * 20,
                        particles: [],
                        wasteType: CONFIG.wasteTypes[idx % CONFIG.wasteTypes.length]
                    };

                    // Assign particles to cluster
                    for (let j = 0; j < particlesPerCluster && wasteIndex < wasteEnd; j++, wasteIndex++) {
                        const i3 = wasteIndex * 3;
                        this.clusterIds[wasteIndex] = idx;
                        cluster.particles.push(wasteIndex);

                        // Position near cluster center
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const r = Math.random() * cluster.radius;

                        this.positions[i3] = pos.x + r * Math.sin(phi) * Math.cos(theta);
                        this.positions[i3 + 1] = pos.y + r * Math.sin(phi) * Math.sin(theta);
                        this.positions[i3 + 2] = pos.z + r * Math.cos(phi);
                    }

                    this.anomalyClusters.push(cluster);
                });
            }

            setupGeometry() {
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.alphas, 1));
                this.geometry.setAttribute('phase', new THREE.BufferAttribute(this.phases, 1));
            }

            createMaterial() {
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute float alpha;
                        attribute float phase;

                        varying vec3 vColor;
                        varying float vAlpha;

                        uniform float uTime;
                        uniform float uPixelRatio;

                        void main() {
                            vColor = color;
                            vAlpha = alpha;

                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                            float pulse = 1.0 + sin(uTime * 2.5 + phase) * 0.15;
                            gl_PointSize = size * pulse * uPixelRatio * (250.0 / -mvPosition.z);
                            gl_PointSize = clamp(gl_PointSize, 1.0, 20.0);

                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vAlpha;

                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if (dist > 0.5) discard;

                            float glow = 1.0 - dist * 2.0;
                            glow = pow(glow, 1.5);

                            gl_FragColor = vec4(vColor, vAlpha * glow);
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    vertexColors: true
                });

                this.points = new THREE.Points(this.geometry, this.material);
            }

            update(deltaTime, time) {
                const dt = Math.min(deltaTime, 0.033);
                this.material.uniforms.uTime.value = time;

                const streamWidth = 600;
                const speciesConfigs = [
                    CONFIG.particles.species.spend,
                    CONFIG.particles.species.waste,
                    CONFIG.particles.species.profit
                ];

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const species = this.species[i];
                    const config = speciesConfigs[species];

                    let x = this.positions[i3];
                    let y = this.positions[i3 + 1];
                    let z = this.positions[i3 + 2];
                    let vx = this.velocities[i3];
                    let vy = this.velocities[i3 + 1];
                    let vz = this.velocities[i3 + 2];

                    // Simple background flow - no cluster behavior
                    // Stream flow
                    vx += (CONFIG.physics.streamSpeed - vx) * 0.01;

                    // Gentle cohesion to center
                    vy += -y * CONFIG.physics.cohesion * 0.5;

                    // Subtle turbulence for visual interest
                    if (!state.accessibility.reduceMotion) {
                        vx += (Math.random() - 0.5) * config.turbulence * 0.5 * dt * 60;
                        vy += (Math.random() - 0.5) * config.turbulence * 0.5 * dt * 60;
                    }

                    // Apply damping
                    vx *= CONFIG.physics.damping;
                    vy *= CONFIG.physics.damping;
                    vz *= CONFIG.physics.damping;

                    // Update position
                    x += vx * dt * 60;
                    y += vy * dt * 60;
                    z += vz * dt * 60;

                    // Wrap around
                    if (x > streamWidth) {
                        x = -streamWidth;
                        y = (Math.random() - 0.5) * 200;
                        z = -800 + Math.random() * 700;  // Stay in background - EXPANDED DEPTH
                    } else if (x < -streamWidth) {
                        x = streamWidth;
                    }

                    // Clamp Y and Z - keep in BACKGROUND
                    y = Math.max(-150, Math.min(150, y));
                    z = Math.max(-800, Math.min(-100, z));  // Background layer only - EXPANDED DEPTH

                    // Store
                    this.positions[i3] = x;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = z;
                    this.velocities[i3] = vx;
                    this.velocities[i3 + 1] = vy;
                    this.velocities[i3 + 2] = vz;
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
            }

            applyHandForce(particleIndex, handPos, type, strength) {
                const i3 = particleIndex * 3;
                const dx = handPos.x - this.positions[i3];
                const dy = handPos.y - this.positions[i3 + 1];
                const dz = handPos.z - this.positions[i3 + 2];
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                if (dist < CONFIG.physics.handRadius && dist > 0) {
                    const force = (1 - dist / CONFIG.physics.handRadius) * CONFIG.physics.handStrength * strength;
                    const dir = type === 'attract' ? 1 : -1;

                    this.velocities[i3] += (dx / dist) * force * dir;
                    this.velocities[i3 + 1] += (dy / dist) * force * dir;
                    this.velocities[i3 + 2] += (dz / dist) * force * dir * 0.5;
                }
            }

            getClusterAtPosition(worldPos, threshold = 60) {
                for (const cluster of this.anomalyClusters) {
                    const dist = cluster.center.distanceTo(worldPos);
                    if (dist < threshold) {
                        return cluster;
                    }
                }
                return null;
            }
        }

        // =====================================================
        // 5. AI CORE ORB CLASS
        // =====================================================
        class AICore {
            constructor() {
                this.group = new THREE.Group();

                // Core icosahedron
                const coreGeo = new THREE.IcosahedronGeometry(25, 1);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);

                // Wireframe
                const wireMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.4
                });
                this.wireframe = new THREE.Mesh(coreGeo.clone(), wireMat);
                this.wireframe.scale.setScalar(1.1);

                // Glow shell
                const glowGeo = new THREE.IcosahedronGeometry(35, 1);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                this.glow = new THREE.Mesh(glowGeo, glowMat);

                // Orbit rings
                this.rings = [];
                const ringColors = [0xff6600, 0x00ff88, 0xffcc00];
                ringColors.forEach((color, i) => {
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(40 + i * 12, 0.8, 16, 64),
                        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2 + i * 0.4;
                    ring.rotation.y = i * 0.6;
                    this.rings.push(ring);
                    this.group.add(ring);
                });

                // Point light
                this.light = new THREE.PointLight(0x00ffff, 2, 300);

                this.group.add(this.core, this.wireframe, this.glow, this.light);
                this.group.position.set(200, 50, -100);

                this.pulseIntensity = 0;
            }

            update(time) {
                this.core.rotation.y = time * 0.3;
                this.core.rotation.x = Math.sin(time * 0.4) * 0.1;
                this.wireframe.rotation.y = -time * 0.2;

                this.rings.forEach((ring, i) => {
                    ring.rotation.z = time * (0.4 + i * 0.15);
                });

                // Pulse effect
                if (this.pulseIntensity > 0) {
                    this.pulseIntensity *= 0.95;
                    this.core.material.opacity = 0.8 + this.pulseIntensity * 0.2;
                    this.glow.material.opacity = 0.1 + this.pulseIntensity * 0.2;
                    this.light.intensity = 2 + this.pulseIntensity * 3;

                    const scale = 1 + this.pulseIntensity * 0.3;
                    this.glow.scale.setScalar(scale);
                }

                // Gentle float
                this.group.position.y = 50 + Math.sin(time * 0.5) * 10;
            }

            pulse() {
                this.pulseIntensity = 1;
            }
        }

        // =====================================================
        // 6. SCROLL MANAGER
        // =====================================================
        function initScrollManager() {
            const scrollContainer = document.getElementById('scroll-container');
            const pageHeight = window.innerHeight * 6;

            window.addEventListener('scroll', () => {
                state.scroll.targetY = window.scrollY;
            }, { passive: true });
        }

        function updateScroll() {
            state.scroll.y += (state.scroll.targetY - state.scroll.y) * 0.1;

            const pageHeight = window.innerHeight * 6 - window.innerHeight;
            state.scroll.progress = Math.min(1, Math.max(0, state.scroll.y / pageHeight));

            // Determine chapter
            let newChapter = 1;
            for (const [chapter, bounds] of Object.entries(CONFIG.chapters)) {
                if (state.scroll.progress >= bounds.start && state.scroll.progress < bounds.end) {
                    newChapter = parseInt(chapter);
                    state.scroll.chapterProgress = (state.scroll.progress - bounds.start) / (bounds.end - bounds.start);
                    break;
                }
            }

            if (newChapter !== state.scroll.currentChapter) {
                onChapterChange(state.scroll.currentChapter, newChapter);
                state.scroll.currentChapter = newChapter;
            }

            document.getElementById('chapter-num').textContent = state.scroll.currentChapter;
        }

        function onChapterChange(oldChapter, newChapter) {
            // Chapter-specific effects
            if (newChapter === 4) {
                animatePipelineSteps();
            }
        }

        function animatePipelineSteps() {
            const steps = document.querySelectorAll('.step');
            steps.forEach((step, i) => {
                setTimeout(() => {
                    step.classList.add('active');
                }, i * 400);
            });
        }

        // =====================================================
        // 7. CAMERA CONTROLLER
        // =====================================================
        function updateCamera() {
            const chapter = CONFIG.chapters[state.scroll.currentChapter];
            const target = new THREE.Vector3(chapter.camera.x, chapter.camera.y, chapter.camera.z);

            // Blend toward next chapter near boundaries
            const nextChapter = CONFIG.chapters[state.scroll.currentChapter + 1];
            if (nextChapter && state.scroll.chapterProgress > 0.7) {
                const blend = (state.scroll.chapterProgress - 0.7) / 0.3;
                const nextTarget = new THREE.Vector3(nextChapter.camera.x, nextChapter.camera.y, nextChapter.camera.z);
                target.lerp(nextTarget, blend);
            }

            camera.position.lerp(target, 0.03);
            camera.lookAt(0, -30, -200); // Looking down at particles
        }

        // =====================================================
        // 8. HAND TRACKING
        // =====================================================
        let hands, handCamera;

        async function initHandTracking() {
            const video = document.getElementById('hand-video');

            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            handCamera = new Camera(video, {
                onFrame: async () => {
                    if (state.hands.enabled) {
                        await hands.send({ image: video });
                    }
                },
                width: 640,
                height: 480
            });
        }

        function onHandResults(results) {
            state.hands.left = null;
            state.hands.right = null;
            state.hands.leftGesture = 'idle';
            state.hands.rightGesture = 'idle';

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label;

                    const worldPos = landmarksToWorld(landmarks);
                    const gesture = detectGesture(landmarks, handedness);

                    // MediaPipe mirrors, so swap
                    if (handedness === 'Left') {
                        state.hands.right = worldPos;
                        state.hands.rightGesture = gesture;
                    } else {
                        state.hands.left = worldPos;
                        state.hands.leftGesture = gesture;
                    }
                }
            }

            // Update particle system hand forces
            if (particleSystem) {
                particleSystem.handForces.left = state.hands.left;
                particleSystem.handForces.right = state.hands.right;
            }

            // Update Hand Cursor - show visual indicator for primary hand
            const primaryHand = state.hands.right || state.hands.left;
            const primaryGesture = state.hands.right ? state.hands.rightGesture : state.hands.leftGesture;

            if (primaryHand && handCursorManager) {
                handCursorManager.setPosition(primaryHand);
                handCursorManager.setGesture(primaryGesture);
            } else if (handCursorManager) {
                handCursorManager.hide();
            }

            // Update HUD
            document.getElementById('left-gesture').textContent = state.hands.leftGesture.toUpperCase();
            document.getElementById('right-gesture').textContent = state.hands.rightGesture.toUpperCase();

            // Check for enemy hits when executing (pinch gesture)
            if (primaryHand && primaryGesture === 'execute') {
                checkHandHits(primaryHand);
            }

            // Check for boost collection (any gesture near boost)
            if (primaryHand) {
                checkBoostCollection(primaryHand);
            }

            // Check for Ultimate Two-Hand Move
            if (state.hands.left && state.hands.right &&
                state.hands.leftGesture === 'capture' &&
                state.hands.rightGesture === 'execute') {

                const handDist = state.hands.left.distanceTo(state.hands.right);
                if (handDist < 150 && !state.ultimateCooldown) {
                    triggerUltimateMove();
                }
            }
        }

        // Check for enemy hits with hand
        function checkHandHits(handPos) {
            // Debounce hits
            const now = Date.now();
            if (now - state.handCursor.lastHitTime < 300) return;

            if (!enemyManager) return;

            const hit = enemyManager.checkHit(handPos, state.handCursor.captureRadius);
            if (hit) {
                state.handCursor.lastHitTime = now;

                // Visual feedback
                if (handCursorManager) handCursorManager.pulseHit();

                // Sound
                ViralEngine.Audio.play('captureCrunch');

                // Screen shake (light)
                ViralEngine.Effects.screenShake(0.2);

                // Calculate points with multiplier
                const multiplier = state.boosts.activeMultiplier * state.gameMode.combo.multiplier;
                const points = Math.floor(hit.points * multiplier);

                // Update game state
                if (state.gameMode.active && state.gameMode.state === 'playing') {
                    state.gameMode.score += points;
                    state.gameMode.captures++;
                    ViralEngine.GameMode.updateCombo();
                    ViralEngine.GameMode.updateGameHUD();
                }

                // Number popup at enemy position
                ViralEngine.Effects.numberPopup(hit.position, points);

                // Update waste detected
                state.particles.wasteDetected++;
                state.particles.captureCount++;
                const wasteEl2 = document.getElementById('waste-amount');
                if (wasteEl2) wasteEl2.textContent = '$' + state.particles.wasteDetected.toLocaleString();

                // Achievement
                if (state.particles.captureCount === 1) {
                    ViralEngine.Achievements.check('firstBlood', true);
                }

                // Hand tracking achievement
                if (state.hands.enabled) {
                    ViralEngine.Achievements.check('handMaster', true);
                }
            }
        }

        // Check for boost collection
        function checkBoostCollection(handPos) {
            if (!boostManager) return;

            const collected = boostManager.checkHit(handPos, state.handCursor.captureRadius);
            if (collected) {
                // Sound
                ViralEngine.Audio.play('successArpeggio');

                // Flash effect (green)
                ViralEngine.Effects.flash(collected.type.glowColor, 0.2);

                // Apply boost effect
                switch(collected.effect) {
                    case 'bonus':
                        // Instant point bonus
                        if (state.gameMode.active) {
                            state.gameMode.score += collected.value;
                            ViralEngine.GameMode.updateGameHUD();
                        }
                        ViralEngine.Effects.numberPopup(collected.position, collected.value);
                        showBoostLabel(collected.position, `+${collected.value} BONUS!`, collected.type.glowColor);
                        break;

                    case 'clear':
                        // Clear nearby enemies
                        clearNearbyEnemies(collected.position, collected.value);
                        showBoostLabel(collected.position, 'SQL SWEEP!', collected.type.glowColor);
                        break;

                    case 'multiplier':
                        // Temporary multiplier
                        state.boosts.activeMultiplier = collected.value;
                        state.boosts.multiplierEndTime = Date.now() + collected.duration;
                        showBoostLabel(collected.position, `${collected.value}X MULTIPLIER!`, collected.type.glowColor);
                        break;
                }
            }
        }

        // Clear nearby enemies (SQL sweep boost)
        function clearNearbyEnemies(center, count) {
            if (!enemyManager) return;

            let cleared = 0;
            const sorted = [...enemyManager.enemies]
                .filter(e => e.active)
                .map(e => ({ enemy: e, dist: e.position.distanceTo(center) }))
                .sort((a, b) => a.dist - b.dist);

            for (const item of sorted) {
                if (cleared >= count) break;
                const idx = enemyManager.enemies.indexOf(item.enemy);
                if (idx >= 0) {
                    const hit = enemyManager.hitEnemy(item.enemy, idx);
                    if (hit && hit.destroyed) {
                        cleared++;
                        if (state.gameMode.active) {
                            state.gameMode.score += hit.points;
                        }
                    }
                }
            }

            if (cleared > 0) {
                ViralEngine.Effects.screenShake(0.4);
                ViralEngine.Effects.confetti(50);
                ViralEngine.GameMode.updateGameHUD();
            }
        }

        // Show boost collection label
        function showBoostLabel(worldPos, text, color) {
            const pos = worldPos.clone().project(camera);
            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

            const label = document.createElement('div');
            label.className = 'boost-collect-label';
            label.textContent = text;
            label.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                transform: translate(-50%, -50%);
                color: ${color};
                text-shadow: 0 0 15px ${color}, 0 0 30px ${color};
                z-index: 700;
            `;
            document.body.appendChild(label);
            setTimeout(() => label.remove(), 1000);
        }

        // Ultimate Two-Hand Move
        let ultimateCooldown = false;
        function triggerUltimateMove() {
            if (ultimateCooldown) return;
            ultimateCooldown = true;

            // Achievement check
            ViralEngine.Achievements.check('ultimateWarrior', true);
            if (state.hands.enabled) {
                ViralEngine.Achievements.check('handMaster', true);
            }

            // Slow motion effect
            state.timing.timeScale = 0.3;

            // Big screen shake
            ViralEngine.Effects.screenShake(0.8);

            // Flash
            ViralEngine.Effects.flash('#00ffff', 0.4);

            // Ultimate sound
            ViralEngine.Audio.play('ultimateBoom');

            // Big score bonus in game mode
            if (state.gameMode.active) {
                const bonus = 10000 * state.gameMode.combo.multiplier;
                state.gameMode.score += bonus;
                ViralEngine.GameMode.updateGameHUD();

                // Show big popup
                if (camera) {
                    ViralEngine.Effects.numberPopup(new THREE.Vector3(0, 0, 0), bonus);
                }
            }

            // Confetti
            ViralEngine.Effects.confetti(150);

            // Pulse AI Core intensely
            if (aiCore) {
                aiCore.pulseIntensity = 3;
            }

            // Convert nearby waste particles
            if (particleSystem) {
                const center = new THREE.Vector3().addVectors(state.hands.left, state.hands.right).multiplyScalar(0.5);
                const convertRadius = 200;

                for (let i = 0; i < particleSystem.count; i++) {
                    if (particleSystem.species[i] === 1) { // Waste
                        const i3 = i * 3;
                        const pos = new THREE.Vector3(
                            particleSystem.positions[i3],
                            particleSystem.positions[i3 + 1],
                            particleSystem.positions[i3 + 2]
                        );

                        if (pos.distanceTo(center) < convertRadius) {
                            // Boost velocity outward
                            const dir = pos.clone().sub(center).normalize();
                            particleSystem.velocities[i3] += dir.x * 8;
                            particleSystem.velocities[i3 + 1] += dir.y * 8;
                            particleSystem.velocities[i3 + 2] += dir.z * 4;

                            // Change color toward profit
                            particleSystem.colors[i3] = 0;
                            particleSystem.colors[i3 + 1] = 1;
                            particleSystem.colors[i3 + 2] = 0.6;
                        }
                    }
                }
                particleSystem.geometry.attributes.color.needsUpdate = true;
            }

            // Restore normal speed after delay
            setTimeout(() => {
                state.timing.timeScale = 1;
            }, 800);

            // Cooldown
            setTimeout(() => {
                ultimateCooldown = false;
            }, 3000);
        }

        function landmarksToWorld(landmarks) {
            const palm = landmarks[9];
            // Map hand position to play area coordinates
            // X and Y map to screen, Z is fixed in middle of play area for hit detection
            return new THREE.Vector3(
                -(palm.x - 0.5) * 700,        // Wider range for X
                -(palm.y - 0.5) * 400,        // Y range
                -250                           // Fixed Z in middle of play area (-400 to -100)
            );
        }

        function detectGesture(landmarks, handedness) {
            // Pinch detection
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(
                (thumbTip.x - indexTip.x) ** 2 +
                (thumbTip.y - indexTip.y) ** 2 +
                (thumbTip.z - indexTip.z) ** 2
            );

            if (pinchDist < 0.08) return 'execute';

            // Open palm detection
            const fingerTips = [8, 12, 16, 20];
            const fingerMcps = [5, 9, 13, 17];
            let extended = 0;

            for (let i = 0; i < 4; i++) {
                if (landmarks[fingerTips[i]].y < landmarks[fingerMcps[i]].y - 0.03) {
                    extended++;
                }
            }

            if (extended >= 4) return 'capture';

            return 'idle';
        }

        // =====================================================
        // 9. INPUT MANAGER (Mouse/Touch)
        // =====================================================
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let hoveredCluster = null;

        function initInputManager() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            document.addEventListener('touchstart', onTouch, { passive: true });

            document.getElementById('cta-sticky').addEventListener('click', scrollToForm);

            // Query cards
            document.querySelectorAll('.query-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.query-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    triggerSQLBurst();
                });
            });

            // Qualification checkboxes
            document.querySelectorAll('.qualification-checklist input').forEach(checkbox => {
                checkbox.addEventListener('change', updateQualification);
            });

            // === VIRAL FEATURES EVENT LISTENERS ===

            // Play Mode Button
            document.getElementById('play-mode-btn').addEventListener('click', () => {
                ViralEngine.GameMode.start();
            });

            // Results Screen Buttons
            document.getElementById('play-again-btn').addEventListener('click', () => {
                ViralEngine.GameMode.closeResults();
                setTimeout(() => ViralEngine.GameMode.start(), 300);
            });

            document.getElementById('share-btn').addEventListener('click', () => {
                ViralEngine.Social.copyToClipboard();
            });

            document.getElementById('close-results-btn').addEventListener('click', () => {
                ViralEngine.GameMode.closeResults();
            });

            document.getElementById('get-audit-btn').addEventListener('click', () => {
                ViralEngine.GameMode.closeResults();
                setTimeout(() => scrollToForm(), 300);
            });

            // Sound Toggle
            document.getElementById('sound-toggle').addEventListener('click', () => {
                ViralEngine.Audio.toggle();
            });

            // Calculator
            document.getElementById('analyze-btn').addEventListener('click', () => {
                const spend = parseInt(document.getElementById('spend-input').value) || 50000;
                ViralEngine.Calculator.analyze(spend);
            });

            document.getElementById('skip-calc').addEventListener('click', (e) => {
                e.preventDefault();
                ViralEngine.Calculator.hide();
            });
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Get world position at play area depth
            if (camera) {
                raycaster.setFromCamera(mouse, camera);
                // Calculate intersection at z = -200 (middle of play area)
                const planeZ = -200;
                const t = (planeZ - camera.position.z) / raycaster.ray.direction.z;
                state.mouseWorldPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(t));
            }

            // Check for enemy hover (show tooltip)
            if (enemyManager && camera && state.mouseWorldPos) {
                const tooltip = document.getElementById('tooltip');
                let foundEnemy = null;

                for (const enemy of enemyManager.enemies) {
                    if (!enemy.active) continue;
                    const screenDist = getScreenDistance(enemy.position, event.clientX, event.clientY);
                    if (screenDist < 50) {
                        foundEnemy = enemy;
                        break;
                    }
                }

                if (foundEnemy && foundEnemy !== hoveredCluster) {
                    hoveredCluster = foundEnemy;
                    tooltip.querySelector('.tooltip-label').textContent = foundEnemy.type.label;
                    tooltip.querySelector('.tooltip-value').textContent = foundEnemy.type.value;
                    tooltip.classList.add('visible');
                }

                if (foundEnemy) {
                    tooltip.style.left = `${event.clientX + 15}px`;
                    tooltip.style.top = `${event.clientY + 15}px`;
                } else {
                    tooltip.classList.remove('visible');
                    hoveredCluster = null;
                }
            }
        }

        // Get screen distance between 3D point and screen coordinates
        function getScreenDistance(worldPos, screenX, screenY) {
            const projected = worldPos.clone().project(camera);
            const px = (projected.x * 0.5 + 0.5) * window.innerWidth;
            const py = (-projected.y * 0.5 + 0.5) * window.innerHeight;
            return Math.hypot(px - screenX, py - screenY);
        }

        function onClick(event) {
            if (event.target.closest('button, input, select, textarea, label, a, .form-panel')) return;

            // Displace particles at click position (visual feedback for all clicks)
            if (state.mouseWorldPos) {
                displaceParticlesAt3D(state.mouseWorldPos, 120, 8);
            }

            // Check for enemy hit at click position
            if (state.mouseWorldPos && enemyManager) {
                checkMouseHit(event.clientX, event.clientY);
            }
        }

        function onTouch(event) {
            if (event.target.closest('button, input, select, textarea, label, a, .form-panel')) return;

            const touch = event.touches[0];
            if (touch) {
                // Calculate world position for touch
                const mx = (touch.clientX / window.innerWidth) * 2 - 1;
                const my = -(touch.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera({ x: mx, y: my }, camera);
                const planeZ = -200;
                const t = (planeZ - camera.position.z) / raycaster.ray.direction.z;
                const touchWorldPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(t));

                // Displace particles at touch position (visual feedback for all touches)
                displaceParticlesAt3D(touchWorldPos, 120, 8);

                checkMouseHit(touch.clientX, touch.clientY, touchWorldPos);
            }
        }

        // Displace particles in 3D space at impact point
        function displaceParticlesAt3D(worldPos, radius = 150, force = 12) {
            if (!particleSystem) return;

            for (let i = 0; i < particleSystem.count; i++) {
                const i3 = i * 3;
                const px = particleSystem.positions[i3];
                const py = particleSystem.positions[i3 + 1];
                const pz = particleSystem.positions[i3 + 2];

                // Calculate 3D distance from impact point
                const dx = px - worldPos.x;
                const dy = py - worldPos.y;
                const dz = pz - worldPos.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                if (dist < radius && dist > 0) {
                    // Displacement falls off with distance
                    const falloff = 1 - (dist / radius);
                    const pushForce = force * falloff;

                    // Apply force in all 3 dimensions (normalized direction * force)
                    const norm = dist;
                    particleSystem.velocities[i3] += (dx / norm) * pushForce;
                    particleSystem.velocities[i3 + 1] += (dy / norm) * pushForce;
                    particleSystem.velocities[i3 + 2] += (dz / norm) * pushForce;
                }
            }
        }

        // Check for enemy/boost hit from mouse/touch
        function checkMouseHit(screenX, screenY, worldPos = null) {
            const checkPos = worldPos || state.mouseWorldPos;
            if (!checkPos) return;

            // Check enemies
            if (enemyManager) {
                let hitEnemy = null;
                let hitIndex = -1;

                for (let i = 0; i < enemyManager.enemies.length; i++) {
                    const enemy = enemyManager.enemies[i];
                    if (!enemy.active) continue;

                    const screenDist = getScreenDistance(enemy.position, screenX, screenY);
                    if (screenDist < 60) {
                        hitEnemy = enemy;
                        hitIndex = i;
                        break;
                    }
                }

                if (hitEnemy) {
                    const hit = enemyManager.hitEnemy(hitEnemy, hitIndex);
                    if (hit) {
                        // Sound
                        ViralEngine.Audio.play('captureCrunch');

                        // Screen shake
                        ViralEngine.Effects.screenShake(0.2);

                        // Calculate points
                        const multiplier = state.boosts.activeMultiplier * state.gameMode.combo.multiplier;
                        const points = Math.floor(hit.points * multiplier);

                        // Update game state
                        if (state.gameMode.active && state.gameMode.state === 'playing') {
                            state.gameMode.score += points;
                            state.gameMode.captures++;
                            ViralEngine.GameMode.updateCombo();
                            ViralEngine.GameMode.updateGameHUD();
                        }

                        // Number popup
                        ViralEngine.Effects.numberPopup(hit.position, points);

                        // Update HUD
                        state.particles.wasteDetected++;
                        state.particles.captureCount++;
                        const wasteEl = document.getElementById('waste-amount');
                        if (wasteEl) wasteEl.textContent = '$' + state.particles.wasteDetected.toLocaleString();

                        // Achievements
                        if (state.particles.captureCount === 1) {
                            ViralEngine.Achievements.check('firstBlood', true);
                        }

                        return;
                    }
                }
            }

            // Check boosts
            if (boostManager) {
                for (let i = 0; i < boostManager.boosts.length; i++) {
                    const boost = boostManager.boosts[i];
                    if (!boost.active) continue;

                    const screenDist = getScreenDistance(boost.position, screenX, screenY);
                    if (screenDist < 50) {
                        const collected = boostManager.collectBoost(boost, i);
                        if (collected) {
                            ViralEngine.Audio.play('successArpeggio');
                            ViralEngine.Effects.flash(collected.type.glowColor, 0.2);

                            switch(collected.effect) {
                                case 'bonus':
                                    if (state.gameMode.active) {
                                        state.gameMode.score += collected.value;
                                        ViralEngine.GameMode.updateGameHUD();
                                    }
                                    ViralEngine.Effects.numberPopup(collected.position, collected.value);
                                    showBoostLabel(collected.position, `+${collected.value} BONUS!`, collected.type.glowColor);
                                    break;
                                case 'clear':
                                    clearNearbyEnemies(collected.position, collected.value);
                                    showBoostLabel(collected.position, 'SQL SWEEP!', collected.type.glowColor);
                                    break;
                                case 'multiplier':
                                    state.boosts.activeMultiplier = collected.value;
                                    state.boosts.multiplierEndTime = Date.now() + collected.duration;
                                    showBoostLabel(collected.position, `${collected.value}X MULTIPLIER!`, collected.type.glowColor);
                                    break;
                            }
                        }
                        return;
                    }
                }
            }

            // No direct hit - trigger general optimization effect
            triggerOptimization();
        }

        function scrollToForm() {
            document.getElementById('chapter-6').scrollIntoView({ behavior: 'smooth' });
        }

        // =====================================================
        // 10. INTERACTION EFFECTS
        // =====================================================
        function triggerOptimization() {
            if (state.particles.optimizing) return;

            state.particles.optimizing = true;
            state.particles.captureCount++;

            // Pulse AI Core
            if (aiCore) aiCore.pulse();

            // Calculate savings
            const baseSavings = Math.floor(Math.random() * 3000) + 1500;
            let savings = baseSavings;

            // If game mode active, add to score with multiplier
            if (state.gameMode.active) {
                savings = ViralEngine.GameMode.addScore(baseSavings);
            }

            state.particles.savingsUnlocked += savings;
            state.hud.sqlQueries++;

            // === VIRAL EFFECTS ===

            // Play capture sound
            ViralEngine.Audio.play('capture');

            // Screen shake
            ViralEngine.Effects.screenShake(0.2);

            // Flash effect
            ViralEngine.Effects.flash('#00ff88', 0.15);

            // Number popup at random position near center
            if (camera) {
                const popupPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 50,
                    0
                );
                ViralEngine.Effects.numberPopup(popupPos, savings);
            }

            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate([15]);
            }

            updateHUD();

            // Pulse CTA (only if not in game mode)
            if (!state.gameMode.active) {
                const cta = document.getElementById('cta-sticky');
                cta.classList.add('pulse');
                setTimeout(() => cta.classList.remove('pulse'), 1500);
            }

            setTimeout(() => {
                state.particles.optimizing = false;
            }, 300);
        }

        function triggerSQLBurst() {
            if (aiCore) aiCore.pulse();
            state.hud.sqlQueries++;
            updateHUD();
        }

        function updateQualification() {
            const checked = document.querySelectorAll('.qualification-checklist input:checked').length;
            const ratio = checked / 4;

            // Update vignette opacity based on qualification
            document.querySelector('.vignette').style.opacity = 1 - ratio * 0.5;
        }

        function updateHUD() {
            const wasteEl = document.getElementById('waste-amount');
            const savingsEl = document.getElementById('savings-amount');
            const sqlEl = document.getElementById('sql-count');

            wasteEl.textContent = '$' + state.particles.wasteDetected.toLocaleString();
            savingsEl.textContent = '$' + state.particles.savingsUnlocked.toLocaleString();
            sqlEl.textContent = state.hud.sqlQueries;

            // Pulse animation
            wasteEl.classList.add('pulse');
            savingsEl.classList.add('pulse');
            setTimeout(() => {
                wasteEl.classList.remove('pulse');
                savingsEl.classList.remove('pulse');
            }, 400);
        }

        // =====================================================
        // 11. ACCESSIBILITY
        // =====================================================
        // toggleReduceMotion function removed - button no longer exists

        // Check prefers-reduced-motion
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            state.accessibility.reduceMotion = true;
            document.body.classList.add('reduce-motion');
        }

        // =====================================================
        // 12. THREE.JS SETUP
        // =====================================================
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            // Add fog for depth perception - particles/enemies fade into distance
            scene.fog = new THREE.Fog(0x0a0a0f, 200, 600);

            // Camera - fixed position, play area is in front
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                1,
                1000
            );
            camera.position.set(0, 100, 400); // Raised camera to look down
            camera.lookAt(0, -30, -200); // Looking down at particles

            // Renderer
            const canvas = document.getElementById('main-canvas');
            renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);

            // Initialize Enemy Manager
            enemyManager = new EnemyManager();
            scene.add(enemyManager.group);

            // Initialize Boost Manager
            boostManager = new BoostManager();
            scene.add(boostManager.group);

            // Initialize Hand Cursor
            handCursorManager = new HandCursorManager();
            scene.add(handCursorManager.group);

            // Spawn initial enemies
            for (let i = 0; i < 6; i++) {
                enemyManager.spawn();
            }

            // Spawn initial boosts
            for (let i = 0; i < 2; i++) {
                boostManager.spawn();
            }

            // Resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            if (particleSystem) {
                particleSystem.material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
            }
        }

        // =====================================================
        // 13. ANIMATION LOOP
        // =====================================================
        let fpsFrames = 0;
        let fpsTime = 0;

        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);

            // Delta time
            const rawDelta = (currentTime - state.timing.lastTime) / 1000;
            const deltaTime = Math.min(rawDelta, 0.05);
            state.timing.lastTime = currentTime;
            state.timing.elapsed += deltaTime;

            // FPS calculation
            fpsFrames++;
            fpsTime += rawDelta;
            if (fpsTime >= 0.5) {
                state.hud.fps = Math.round(fpsFrames / fpsTime);
                document.getElementById('fps').textContent = state.hud.fps;
                fpsFrames = 0;
                fpsTime = 0;
            }

            // Skip if hidden
            if (document.hidden) return;

            // Updates
            updateScroll();
            updateCamera();

            if (particleSystem) {
                particleSystem.update(deltaTime, state.timing.elapsed);
            }

            if (aiCore) {
                aiCore.update(state.timing.elapsed);
            }

            // Update 3D enemies
            if (enemyManager) {
                enemyManager.update(deltaTime, state.timing.elapsed);

                // Spawn enemies periodically
                state.enemies.spawnTimer += deltaTime * 1000;
                if (state.enemies.spawnTimer >= state.enemies.spawnInterval && enemyManager.enemies.length < state.enemies.maxCount) {
                    enemyManager.spawn();
                    state.enemies.spawnTimer = 0;
                    // Faster spawning during game mode
                    if (state.gameMode.active && state.gameMode.state === 'playing') {
                        state.enemies.spawnInterval = 1500;
                    } else {
                        state.enemies.spawnInterval = 2500;
                    }
                }
            }

            // Update boosts
            if (boostManager) {
                boostManager.update(deltaTime, state.timing.elapsed);

                // Spawn boosts periodically
                state.boosts.spawnTimer += deltaTime * 1000;
                if (state.boosts.spawnTimer >= state.boosts.spawnInterval && boostManager.boosts.length < state.boosts.maxCount) {
                    boostManager.spawn();
                    state.boosts.spawnTimer = 0;
                }

                // Check multiplier expiry
                if (state.boosts.activeMultiplier > 1 && Date.now() > state.boosts.multiplierEndTime) {
                    state.boosts.activeMultiplier = 1;
                }
            }

            // Update hand cursor
            if (handCursorManager) {
                handCursorManager.update(state.timing.elapsed);
            }

            // Update screen shake effect
            ViralEngine.Effects.updateShake();

            // Render
            renderer.render(scene, camera);
        }

        // =====================================================
        // 14. INITIALIZATION
        // =====================================================
        function init() {
            // Determine particle count based on device
            let particleCount = CONFIG.particles.baseCount;
            const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
            if (isMobile) {
                particleCount = CONFIG.particles.minCount;
            }

            initThreeJS();

            // Create particle system
            particleSystem = new ParticleSystem(particleCount);
            scene.add(particleSystem.points);

            // Create AI Core
            aiCore = new AICore();
            scene.add(aiCore.group);

            // Initialize systems
            initScrollManager();
            initInputManager();
            initHandTracking();

            // Initialize Viral Engine systems
            ViralEngine.Audio.init();
            ViralEngine.Achievements.init();
            ViralEngine.EasterEggs.init();
            ViralEngine.Touch.init();

            // Show calculator on first visit (optional - comment out to disable)
            // setTimeout(() => ViralEngine.Calculator.show(), 2000);

            // Start animation
            requestAnimationFrame(animate);
        }

        // Run on load
        window.addEventListener('load', init);

        // FAQ Accordion Toggle
        document.querySelectorAll('.faq-question').forEach(button => {
            button.addEventListener('click', () => {
                const faqItem = button.parentElement;
                const isActive = faqItem.classList.contains('active');

                // Close all other FAQ items
                document.querySelectorAll('.faq-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Toggle current item
                if (!isActive) {
                    faqItem.classList.add('active');
                }
            });
        });

        // Screenshot Lightbox Functionality
        window.addEventListener('DOMContentLoaded', () => {
            const lightbox = document.getElementById('image-lightbox');

            if (!lightbox) return;

            // Close Lightbox Function
            const closeLightbox = () => {
                lightbox.classList.remove('active');
                document.body.style.overflow = ''; // Restore scroll
            };

            // Add click handlers to all screenshot frames
            document.querySelectorAll('.screenshot-frame').forEach(frame => {
                frame.addEventListener('click', (e) => {
                    const img = frame.querySelector('img');
                    const caption = frame.nextElementSibling?.textContent || '';

                    lightbox.querySelector('.lightbox-image').src = img.src;
                    lightbox.querySelector('.lightbox-image').alt = img.alt;
                    lightbox.querySelector('.lightbox-caption').textContent = caption;
                    lightbox.classList.add('active');
                    document.body.style.overflow = 'hidden'; // Prevent background scroll
                });
            });

            // Close on click outside or close button
            lightbox.addEventListener('click', (e) => {
                if (e.target.id === 'image-lightbox' || e.target.classList.contains('lightbox-close')) {
                    closeLightbox();
                }
            });

            // Close on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && lightbox.classList.contains('active')) {
                    closeLightbox();
                }
            });
        });
    </script>

    <!-- Image Lightbox -->
    <div id="image-lightbox">
        <button class="lightbox-close" aria-label="Close lightbox">&times;</button>
        <div class="lightbox-container">
            <img class="lightbox-image" src="" alt="">
            <p class="lightbox-caption"></p>
        </div>
    </div>

    <footer>
        <div class="container" style="padding: 0 20px;">
            <p>&copy; 2025 Fame Express LLC | San Francisco, CA</p>
            <p style="margin-top: 10px;">
                <a href="/">Home</a> |
                <a href="/team.html">Team</a> |
                <a href="/privacypolicy.html">Privacy Policy</a> |
                <a href="/terms.html">Terms of Service</a> |
                <a href="/support.html">Customer Support</a>
            </p>
        </div>
    </footer>
</body>
</html>
